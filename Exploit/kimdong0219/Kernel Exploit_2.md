
# Kernel Exploit Development 2

## Introduction - LKM
`loadable kernel module (LKM)`은 커널 재컴파일 없이 작동 중인 OS커널에 실행기능을 모듈로 추가하기 위한 기법이다.<br>

LKM은 현재 리눅스,솔라리스,FreeBSD를 포함한 많은 OS에서 사용되고 있다.<br>

트로이 목마에 감염된 모듈이 LKM에 있으면 시스템을 재부팅한다 해도 부팅 과정에서 다른 커널 모듈들과 마찬가지로 가염된 LKM모듈을 다시 적재하게 된다.<br>

 따라서 LKM사용상의 이점이 널리 인정된다 하더라도 악의적인 침입자들에 의해 악용될수 있기 때문에 기능자체를 반대하는 사람들도 있다.<br>


 `./exercises/mod_sample`에 위치해 있는 커널 모듈을 로드해서 디버깅해보자.<br>

 sample driver는 `/dev/sample` character device를 등록하고 디바이스에서 `reading,closing,opening`을 위한 몇 가지 동작을 구현한다.<br>

 다음 명령어를 사용하여 TestVM에 `sample module`을 로드 시킬수 있다.<br>
 ```sh
 insmod /exercises/mod_sample/sample.ko
 ```
 **로드 시키기전에 /exercises/mod_sample에서 make를 해주어야 한다.**<br>

 device가 로드되면 `opening,closing,reading`은 `device_open,device_close,device_read` 함수로 핸들링된다.<br>

 ```c
 ...
static int device_open(struct inode *inode, struct file *file) {
if (dev_counter)
return -EBUSY;
dev_counter++;
return 0;
}
static int device_close(struct inode *inode, struct file *f) {
dev_counter--;
return 0;
}
static ssize_t device_read(struct file *file, char *buf, size_t size, loff_t *off)
{
char tmp[5] = "test";
printk(KERN_INFO "%s\n", tmp);
return 0;
}
...
```
<br>

`sample character device`를 보면 device_read()는 단순히 `tmp buffer`의 값을 커널 콘솔 로그로 출력해준다.<br>

```c
test@testvm1:˜$ sudo cat /dev/sample
test@testvm1:˜$ dmesg | tail -3
[ 5.354141] init: plymouth-upstart-bridge main process (631) killed by TERM
signal
[ 34.034221] Sample module loaded
[ 57.566450] test
```
<br>

----

## Task 1
첫번째 강의와 마찬가지로, 목표는 `breakpoint`를 trigger하는 것이다.<br>

그러나 이번에는 breakpoint를 LKM에 걸어주어야 한다.<br>

 모듈을 로드한뒤에 `text,bss,data` segment address를 적어두자.<br>

 ```c
test@ubuntu:~/exercises/mod_sample$ sudo cat /sys/module/sample/sections/{.text,.data,.bss}

0xffffffffa0242000
0xffffffffa0244000
0xffffffffa0244338
```
<br>

이제 gdb에서 `symbol file`을 로드하자.<br>

```c
root@master:˜# gdb -q kernels/vmlinux-3.5.0-23-generic
Reading symbols from kernels/vmlinux-3.5.0-23-generic...done.
(gdb) target remote 192.168.40.1:8864
Remote debugging using 192.168.40.1:8864
native_safe_halt () at /build/buildd/linux-lts-quantal-3.5.0/arch/x86/include/asm/
irqflags.h:50
warning: Source file is more recent than executable.
50 }
(gdb) add-symbol-file ./modules/sample.ko 0xffffffffa0242000 -s .data 0xffffffffa0244000 -s .bss 0xffffffffa0244338
add symbol table from file "./modules/sample.ko" at
.text_addr = 0xffffffffa0242000
.data_addr = 0xffffffffa0244000
.bss_addr = 0xffffffffa0244338
(y or n) y
Reading symbols from ./modules/sample.ko...done.
(gdb)
```

<br>
지금 Master VM과 TestVM1의 `sample.c`의 경로가 다르기 때문에 둘이 맞춰주어햐 한다.<br>

여러가지 방법이 있지만 TestVM에서 C파일을 가지고 왔다.<br>

```c
> test@ubuntu:~/exercises$ cp mod_sample/ /root/modules
> root@ubuntu:/root/modules# ls
Makefile       Module.symvers  sample.ko     sample.mod.o
modules.order  sample.c        sample.mod.c  sample.o
> root@ubuntu:/root/modules# make clean
> root@ubuntu:/root/modules# vi sample.c

MODULE_LICENSE("GPL");
MODULE_AUTHOR("root"); << root로 변경
MODULE_DESCRIPTION("Test kernel module.");
MODULE_VERSION("0.1");

> root@ubuntu:/root/modules# make all
```
<br>

이제 이 파일을 Master VM의 /root/modules로 넣어준다.<br>

**TestVM에서 sample device의 경로를 바꾸었기 때문에 symbol의 주소를 다시 가져와야 한다.**

```c
<TestVM>
root@ubuntu:/root/modules# insmod sample.ko
root@ubuntu:/root/modules# sudo cat /sys/module/sample/sections/{.text,.data,.bss}
0xffffffffa0257000
0xffffffffa0259000
0xffffffffa0259338
```
<br>
```c
<Master VM>
root@ubuntu:~/# gdb -q kernels/vmlinux-3.5.0-23-generic
pwndbg> target remote 192.168.74.1:8864
pwndbg> add-symbol-file ./modules/sample.ko 0xffffffffa0257000 -s .data 0xffffffffa0259000 -s .bss 0xffffffffa0259338
add symbol table from file "./modules/sample.ko" at
	.text_addr = 0xffffffffa0257000
	.data_addr = 0xffffffffa0259000
	.bss_addr = 0xffffffffa0259338
Reading symbols from ./modules/sample.ko...done.
```

`device_read`에 breakpoint를 걸어주고 user sapce에서 이 breakpoint를 trigger하자.<br>
![gdb2](https://i.imgur.com/lpXLfqS.png)





**이제 "test" string의 메모리 address를 확인해보자**<br>

**1. 이 주소가 kernel 또는 user space memory 주소인가?**<br>

```c
pwndbg> disas device_read
Dump of assembler code for function device_read:
   0xffffffffa0242050 <+0>:	push   rbp
   0xffffffffa0242051 <+1>:	mov    rbp,rsp
   0xffffffffa0242054 <+4>:	sub    rsp,0x10
   0xffffffffa0242058 <+8>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffffa024205d <+13>:	mov    rdi,0xffffffffa0243024
   0xffffffffa0242064 <+20>:	mov    rax,QWORD PTR gs:0x28
   0xffffffffa024206d <+29>:	mov    QWORD PTR [rbp-0x8],rax
   0xffffffffa0242071 <+33>:	xor    eax,eax
   0xffffffffa0242073 <+35>:	lea    rsi,[rbp-0xd]
   0xffffffffa0242077 <+39>:	mov    DWORD PTR [rbp-0xd],0x74736574
   0xffffffffa024207e <+46>:	mov    BYTE PTR [rbp-0x9],0x0
   0xffffffffa0242082 <+50>:	call   0xffffffff81685975 <printk>
   0xffffffffa0242087 <+55>:	xor    eax,eax
   0xffffffffa0242089 <+57>:	mov    rdx,QWORD PTR [rbp-0x8]
   0xffffffffa024208d <+61>:	xor    rdx,QWORD PTR gs:0x28
   0xffffffffa0242096 <+70>:	jne    0xffffffffa024209a <device_read+74>
   0xffffffffa0242098 <+72>:	leave
   0xffffffffa0242099 <+73>:	ret
   0xffffffffa024209a <+74>:	nop    WORD PTR [rax+rax*1+0x0]
   0xffffffffa02420a0 <+80>:	call   0xffffffff81052a90 <__stack_chk_fail>
```
<br>

주소값을 보면 `user space`주소라고 하기에는 비정상적인 크기를 가지고 있으므로 `kernel memory address`이다.<br>



**2. 이 주소는 stack,heap,bss 또는 다른 데이터 segment에 할당 되어있는가?**<br>

<br>

----

## Task2

<br>

```c
 static ssize_t device_read(struct file *file, char *buf, size_t size, loff_t *off)
 ```
 <br>

 **device_read에서 buf값을 바꿔야하므로 $rsi의 값을 변경해야 한다.**<br>

 **device_read+39에 breakpoint 설정**<br>

  ```c
 pwndbg> disas device_read
Dump of assembler code for function device_read:
   0xffffffffa0257050 <+0>:	push   rbp
   0xffffffffa0257051 <+1>:	mov    rbp,rsp
   0xffffffffa0257054 <+4>:	sub    rsp,0x10
   0xffffffffa0257058 <+8>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffffa025705d <+13>:	mov    rdi,0xffffffffa0258024
   0xffffffffa0257064 <+20>:	mov    rax,QWORD PTR gs:0x28
   0xffffffffa025706d <+29>:	mov    QWORD PTR [rbp-0x8],rax
   0xffffffffa0257071 <+33>:	xor    eax,eax
   0xffffffffa0257073 <+35>:	lea    rsi,[rbp-0xd]
=> 0xffffffffa0257077 <+39>:	mov    DWORD PTR [rbp-0xd],0x74736574
   0xffffffffa025707e <+46>:	mov    BYTE PTR [rbp-0x9],0x0
   0xffffffffa0257082 <+50>:	call   0xffffffff81685975 <printk>
   0xffffffffa0257087 <+55>:	xor    eax,eax
   0xffffffffa0257089 <+57>:	mov    rdx,QWORD PTR [rbp-0x8]
   0xffffffffa025708d <+61>:	xor    rdx,QWORD PTR gs:0x28
   0xffffffffa0257096 <+70>:	jne    0xffffffffa025709a <device_read+74>
   0xffffffffa0257098 <+72>:	leave
   0xffffffffa0257099 <+73>:	ret
   0xffffffffa025709a <+74>:	nop    WORD PTR [rax+rax*1+0x0]
   0xffffffffa02570a0 <+80>:	call   0xffffffff81052a90 <__stack_chk_fail>
```
<br>

 ```c
pwndbg> x/s $rsi
0xffff880078b9feeb:	"test"
pwndbg> set *$rsi=0x676E69727473676E6F6C7972657661736973696874
Numeric constant too large.
pwndbg> set {char[23]}*$rsi="thisisaverylongstring\n"
pwndbg> x/s $rsi
0xffff880078b9feeb:	"test"
pwndbg> set {char[23]}0xffff880078b9feeb="thisisaverylongstring\n"
pwndbg> x/s $rsi
0xffff880078b9feeb:	"thisisaverylongstring\n"
 ```
ni로 진행하다보면 다음과 같이 rsi의 주소안의 값이 test로 저장이 되있다.<br>
그러나 rsi에 자체적으로 아스키 코드를 넣어주니까 오류가 발생했다.<br>
따라서 rsi주소에 형식을 설정해서 직접 string을 넣어주었다.<br>

![error](https://i.imgur.com/7D1SPrd.png)
<br>

<br>


알수없는 Error가 계속 발생하면서 VM이 멈추었다. ㅠㅠ <br>

일단은 값이 변경되는것까지는 확인하였다.<br>

 ## END.
----
