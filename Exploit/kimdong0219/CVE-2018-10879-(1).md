# CVE-2018-10879


### Use After-free detected by KASAN in Ext4

#### <POC.C>

```c
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <dirent.h>
#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/falloc.h>
#include <linux/loop.h>
static void activity(char *mpoint) {
char *foo_bar_baz;
char *foo_baz;
int err;
err = asprintf(&foo_bar_baz, "%s/foo/bar/baz", mpoint);
err = asprintf(&foo_baz, "%s/foo/baz", mpoint);
rename(foo_bar_baz, foo_baz);
}
int main(int argc, char *argv[]) {
activity(argv[1]);
return 0;
}
```

<br>

---

### **Comment**

```c
block 35는 block allocation bitmap으로 사용 된다.
```

**Block allocation이란?** <br>

모든 read-write 파일 시스템들은 파일에 배치할 때 문제가 발생한다. <br>

개별적으로 해결되야할 두가지 문제들이 존재한다. <br>

-	`free Block`을 찾는 과정 <br>
-	특정 파일의`데이터가 저장 되어있는` 블록을 기억하는 과정<br>

`extent`는 블록의 range를 첫번째 블록의 숫자와 블록의 range 길이를 명시한다.<br>

위 두가지 문제점들의 대안은 각 블록의 번호를 따로 보관하는 것인데, 보통은 더 많은 공간이 필요하지만 간단하다.<br>

그래서 많은 파일 시스템들은 `allocation bitmap`을 사용한다.<br>

파일을 구성하는 블록을 저장하는 전통적인 UNIX방법은 extent를 사용하지 않고 블록 번호 목록을 사용한다.<br>

처음에는 inode 구조에 저장된다.(direct block)<br>

이 공간이 차게 되면 한 블록이 추가 블록 번호를 저장하도록 할당 된다.<br>

이 간접 블록의 블록 번호만 inode구조에 저장된다.<br>

그 공간도 소진될시 이 방법을 반복적으로 적용하여 이중 간접 블록 또는 삼중 간접 블록으로 이어진다.<br>

**CVE-2018-10879**에서는 block 35번이 `allocation bitmap`으로 사용 되고 있다.<br>

그리고 그 블럭은 `buffer_verified flag`가 set되어 있다.<br>

그후에 `ext4_xattr_check_block()` 을 호출 할시, code는 `buffer_verified flag`를 체크하고 확인된 블록이라고 판단한다. 그에 따라 2가지 패치를 한다.<br>

**(1) ext4: add corruption check in ext4_xattr_set_entry()**<br>
&nbsp;&nbsp;&nbsp; <b>http://patchwork.ozlabs.org/patch/928666/</b>
<br>

**(2) ext4: always verify the magic number in xattr blocks** <br>
&nbsp;&nbsp;&nbsp; <b>http://patchwork.ozlabs.org/patch/928667/</b>
<br>

---

### Patch

(1) xattr 버퍼를 `overrun`하지 않는지 확인하는 추가적인 체크를 추가했다.<br>

```c
static int ext4_xattr_set_entry(struct ext4_xattr_info *i,handle_t *handle, struct inode *inode, bool is_block)
{
 -struct ext4_xattr_entry *last;
 +struct ext4_xattr_entry *last, *next;
 struct ext4_xattr_entry *here = s->here;
 size_t min_offs = s->end - s->base, name_len = strlen(i->name);
 int in_inode = i->in_inode;
 static int ext4_xattr_set_entry(struct ext4_xattr_info *i,

    /* Compute min_offs and last. */
 last = s->first;
 -for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
 +for (; !IS_LAST_ENTRY(last); last = next) {
 +  next = EXT4_XATTR_NEXT(last);
 +  if ((void *)next >= s->end) {
 +          EXT4_ERROR_INODE(inode, "corrupted xattr entries");
 +          ret = -EFSCORRUPTED;
 +          goto out;
 ...
 +      }
```

(2) inode가 `block allocation bitmap` 같은 다른 종류의 메타데이터 블록을 가리키는 경우에도, `buffer_verified flag` 가 set될수 있다<br>

이러한 경우 외부의 `attribute block` 을 만들수 있다.<br>

`verified flag`를 사용하는 이유는 지속적으로 재검증을 막기 위해서이다.<br>

하지만 `xattr block`의 `magic number`를 확인하는 작업은 많은 overhead가 걸리지 않고 `potential crash`들을 피할수 있다.<br>

```c
__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh)
 {
    int error = -EFSCORRUPTED;

-   if (buffer_verified(bh))
-       return 0;
-
    if (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
        BHDR(bh)->h_blocks != cpu_to_le32(1))
        goto errout;
+   if (buffer_verified(bh))
+       return 0;
+
    error = -EFSBADCRC;
    if (!ext4_xattr_block_csum_verify(inode, bh))
        goto errout;
    ...
  }
```
<br>

**+추가) gdb 에서 code가 인식이 안되면 다음과 같이 하면 된다.<br>**

```c
gef➤  list ext4_rename
3457	fs/ext4/namei.c: No such file or directory.
gef➤  directory ~/linux-4.17/
Source directories searched: /home/fuzzer/linux-4.17:$cdir:$cwd
gef➤  list ext4_rename
3457	 * This comes from rename(const char *oldpath, const char *newpath)
3458	 */
3459	static int ext4_rename(struct inode *old_dir, struct dentry *old_dentry,
3460			       struct inode *new_dir, struct dentry *new_dentry,
3461			       unsigned int flags)
3462	{
3463		handle_t *handle = NULL;
3464		struct ext4_renament old = {
3465			.dir = old_dir,
3466			.dentry = old_dentry,
gef➤
```

----


### 분석 시작

<br>

qemu에서 `Kernel 4.17` 버전에서 `crash image`를 mount시켜서 확인을 해보았다.<br>

기존 CVE에 나와있는 Bug는 다음과 같다.<br>

```c
[ 359.755524] BUG: KASAN: use-after-free in ext4_xattr_set_entry+0x4c2/0x1860
```

내 PC에서 재현시켰을때는 3가지 경우의 bug가 발견되었다.<br>

```c
[  108.120775] BUG: KASAN: use-after-free in ext4_xattr_free_space+0x200/0x300
[  245.355171] BUG: KASAN: use-after-free in ext4_xattr_set_entry+0x32bb/0x3390
[  288.371524] BUG: KASAN: slab-out-of-bounds in ext4_xattr_set_entry+0x1d66/0x3390
```
<br>

**따라서 KASAN에서 나온 주소지 기준으로 Break Point를 걸고 분석을 하려고 한다.**<br>

```c
BUG: use-after-free in ext4_xattr_free_space+0x200/0x300
0x200 : 512
0xffffffff819c48ab <+507>:	call   0xffffffff8163ac70 <__asan_report_load4_noabort>
0xffffffff819c48b0 <+512>:	mov    rcx,QWORD PTR [rsp+0x10]

0x300 : 768
0xffffffff819c49a7 <+759>:	mov    rsi,QWORD PTR [rsp]
0xffffffff819c49ab <+763>:	jmp    0xffffffff819c4737 <ext4_xattr_free_space+135>
```

<br>

```c
BUG: use-after-free in ext4_xattr_set_entry+0x32bb/0x3390

0x32bb:12987

0xffffffff819cc676 <+12982>:	call   0xffffffff8163ac70 <__asan_report_load4_noabort>
0xffffffff819cc67b <+12987>:	mov    rdx,QWORD PTR [rsp+0x70]

0x3390: 13200
0xffffffff819cc735 <+13173>:	mov    QWORD PTR [rsp+0x98],rsi
0xffffffff819cc73d <+13181>:	call   0xffffffff8163ac80 <__asan_report_load8_noabort>
0xffffffff819cc742 <+13186>:	mov    rsi,QWORD PTR [rsp+0x98]
0xffffffff819cc74a <+13194>:	jmp    0xffffffff819cbe54 <ext4_xattr_set_entry+10900>
```
<br>

```c
BUG: slab-out-of-bounds in ext4_xattr_set_entry+0x1d66/0x3390

0x1d66 : 7526
0xffffffff819cb121 <ext4_xattr_set_entry+7521>:	call   0xffffffff81639cc0 <memmove>


0x3390: 13200
0xffffffff819cc735 <+13173>:	mov    QWORD PTR [rsp+0x98],rsi
0xffffffff819cc73d <+13181>:	call   0xffffffff8163ac80 <__asan_report_load8_noabort>
0xffffffff819cc742 <+13186>:	mov    rsi,QWORD PTR [rsp+0x98]
0xffffffff819cc74a <+13194>:	jmp    0xffffffff819cbe54 <ext4_xattr_set_entry+10900>
```

<br>

![backtrace](https://github.com/Kimdong0219/image/blob/master/10879-backtrace.png?raw=true)

다음 이미지는 `ext4_xattr_free_space`에서 bug가 발생했을때의 gdb backtrace이다.<br>

![enter image description here](https://github.com/Kimdong0219/image/blob/master/10879-break1.png?raw=true)

<br>

<br>


Call trace에 따라서 소스코드와 함께 분석을 해보려고 한다.<br>

![breakpoint2](https://github.com/Kimdong0219/image/blob/master/10879-break2.png?raw=true)
<br>




<br>

## `ext4_mark_inode_dirty` 분석

```c
<ext4_mark_inode_dirty>

struct ext4_iloc
{
	struct buffer_head *bh;
	unsigned long offset;
	ext4_group_t block_group;
};

if (EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize)
		ext4_try_to_expand_extra_isize(inode, sbi->s_want_extra_isize,iloc, handle)
```

<br>

```c
<buffer_head>

struct buffer_head {
	unsigned long b_state;		/* buffer state bitmap (see above) */
	struct buffer_head *b_this_page;/* circular list of page's buffers */
	struct page *b_page;		/* the page this bh is mapped to */

	sector_t b_blocknr;		/* start block number */
	size_t b_size;			/* size of mapping */
	char *b_data;			/* pointer to data within the page */

	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;		/* I/O completion */
 	void *b_private;		/* reserved for b_end_io */
	struct list_head b_assoc_buffers; /* associated with another mapping */
	struct address_space *b_assoc_map;	/* mapping this buffer is
						   associated with */
	atomic_t b_count;		/* users using this buffer_head */
};
```
<br>

```c

<EXT4_SB/EXT4_I>

static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)
{
	return sb->s_fs_info; /*Filesystem private info*/
}
static inline struct ext4_inode_info *EXT4_I(struct inode *inode)
{
	return container_of(inode, struct ext4_inode_info, vfs_inode);
}

```

<br>

```c
<ext4_mark_inode_dirty>

unsigned int s_want_extra_isize; /* New inodes should reserve # bytes */

if (EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize)
		ext4_try_to_expand_extra_isize(inode, sbi->s_want_extra_isize,iloc, handle)
```

<br>

`ext4_mark_inode_dirty`에서 `Extra isize`가 `s_want_extra_isize`보다 작으면 `ext4_try_to_expand_extra_isize`로 넘어간다.<br>

----

## `ext4_try_to_expand_extra_isize` 분석
```c
<ext4_try_to_expand_extra_isize>
static int ext4_try_to_expand_extra_isize(struct inode *inode, unsigned int new_extra_isize, struct ext4_iloc iloc, handle_t *handle)

error = __ext4_expand_extra_isize(inode, new_extra_isize, &iloc, handle, &no_expand);
```
저널링을 하지 않는 모드에서는 즉시 inode를 확장 시도가 가능하다.<br>
저널 시스템에서는 `extra buffer credits`을 확보해야한다.<br>
그 이유는 우리가 동일한 방식으로EA block에 써주기 위해서이다.<br>
`journal_extend`가 실패하면 해당 `inode`의 기능성이 약간 상실되는데 기능이 중요하다면 충분한 `s_min_extra_isize`를 실행하도록 e2fsck를 실행해야한다.<br>
`ext4_try_to_expand_extra_isize`에서 `__ext4_expand_extra_isize`를 호출한다.<br>

----
## `__ext4_expand_extra_isize` 분석
```c
static int __ext4_expand_extra_isize(struct inode *inode,unsigned int new_extra_isize, struct ext4_iloc *iloc, handle_t *handle, int *no_expand)
{
  struct ext4_inode *raw_inode;
	struct ext4_xattr_ibody_header *header;
	int error;
	raw_inode = ext4_raw_inode(iloc);
	header = IHDR(inode, raw_inode);
  error = ext4_expand_extra_isize_ea(inode, new_extra_isize, raw_inode, handle);
	if (error) {
		/*
		 * Inode size expansion failed; don't try again
		 */
		*no_expand = 1;
	}

	return error;
}
```
<br>

`__ext4_expand_extra_isize`에서 `ext4_expand_extra_isize_ea`를 호출한다.<br>

----
## `ext4_expand_extra_isize_ea` 분석

```c
<ext4_expand_extra_isize_ea>
int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize, struct ext4_inode *raw_inode, handle_t *handle)
{
	struct ext4_xattr_ibody_header *header;
	struct buffer_head *bh;
	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
	static unsigned int mnt_count;
	size_t min_offs;
	size_t ifree, bfree;
	int total_ino;
	void *base, *end;
	int error = 0, tried_min_extra_isize = 0;
	int s_min_extra_isize = le16_to_cpu(sbi->s_es->s_min_extra_isize);
	int isize_diff = new_extra_isize - EXT4_I(inode)->i_extra_isize;

}
```
함수에 선언된 인자들은 위와 같다.<br>
`isize_diff`는 우리가 i_extra_isize를 얼마나 키워야하는 지에 대한 인자이다.<br>
`isize_diff`= `new_extra_isize - EXT4_I->i_extra_isize` <br>

```c
<ext4_expand_extra_isize_ea>

retry:
	isize_diff = new_extra_isize - EXT4_I(inode)->i_extra_isize;
	if (EXT4_I(inode)->i_extra_isize >= new_extra_isize)
		return 0;
```
<br>

`i_extra_isize`가 `new_extra_isize`보다 클시 0을 반환시켜 버린다.<br>

```c
<ext4_expand_extra_isize_ea>에서 min_offs를 계산하는 방식이다.
	base = IFIRST(header);
	end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;
	min_offs = end - base;
	total_ino = sizeof(struct ext4_xattr_ibody_header);
```
`min_offs`를 계산하는 인자의 값들을 확인해보도록 하자.<br>

```c
#define EXT4_GOOD_OLD_INODE_SIZE 128
#define IHDR(inode, raw_inode) \
	((struct ext4_xattr_ibody_header *) \
		((void *)raw_inode + \
		EXT4_GOOD_OLD_INODE_SIZE + \
		EXT4_I(inode)->i_extra_isize))

#define IFIRST(hdr) ((struct ext4_xattr_entry *)((hdr)+1))

struct ext4_xattr_entry {
	__u8	e_name_len;	/* length of name */
	__u8	e_name_index;	/* attribute name index */
	__le16	e_value_offs;	/* offset in disk block of value */
	__le32	e_value_inum;	/* inode in which the value is stored */
	__le32	e_value_size;	/* size of attribute value */
	__le32	e_hash;		/* hash value of name and value */
	char	e_name[0];	/* attribute name */
};

struct ext4_xattr_ibody_header {
	__le32	h_magic;	/* magic number for identification */
};
```
<br>

```c
ifree = ext4_xattr_free_space(base, &min_offs, base, &total_ino);
	if (ifree >= isize_diff)
		goto shift;
```

`ifree`의 값이 `isize_diff`보다 크다면 shift함수로 보낸다.<br>
하지만 free space가 충분하지 않다면 EA block에 `new_extra_isize` bytes를 체크한다.<br>

```c
<ifree>
fuzzer@ubuntu df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
udev            494414    416  493998    1% /dev
tmpfs           501971    642  501329    1% /run
/dev/sda1      1905008 330225 1574783   18% /
tmpfs           501971      9  501962    1% /dev/shm
tmpfs           501971      4  501967    1% /run/lock
tmpfs           501971     17  501954    1% /sys/fs/cgroup
tmpfs           501971     31  501940    1% /run/user/1000
```
<br>

```c
<bfree>
fuzzer@ubuntu df -BM
Filesystem     1M-blocks   Used Available Use% Mounted on
udev               1932M     0M     1932M   0% /dev
tmpfs               393M    16M      377M   5% /run
/dev/sda1         29147M 10873M    16772M  40% /
tmpfs              1961M     1M     1961M   1% /dev/shm
tmpfs                 5M     0M        5M   0% /run/lock
tmpfs              1961M     0M     1961M   0% /sys/fs/cgroup
tmpfs               393M     1M      393M   1% /run/user/1000
```

```c
bfree = ext4_xattr_free_space(BFIRST(bh), &min_offs, base,
					      NULL);
		brelse(bh);
		if (bfree + ifree < isize_diff) {
			if (!tried_min_extra_isize && s_min_extra_isize) {
				tried_min_extra_isize++;
				new_extra_isize = s_min_extra_isize;
				goto retry;
			}
			error = -ENOSPC;
			goto cleanup;
		}
```
<br>

`ext4_xattr_free_space`를 호출하여 bfree에 값을 저장한다.<br>
`bfree + ifree`가 `isize_diff`보다 작다면 `retry`로 보낸다.<br>


```c
<ext4_expand_extra_isize_ea>



  	error = ext4_xattr_make_inode_space(handle, inode, raw_inode,
  					    isize_diff, ifree, bfree,
  					    &total_ino);
  	if (error) {
  		if (error == -ENOSPC && !tried_min_extra_isize &&
  		    s_min_extra_isize) {
  			tried_min_extra_isize++;
  			new_extra_isize = s_min_extra_isize;
  			goto retry;
  		}
  		goto cleanup;
  	}

```
<br>


```c
<shift>

    shift:
    	/* Adjust the offsets and shift the remaining entries ahead */
    	ext4_xattr_shift_entries(IFIRST(header), EXT4_I(inode)->i_extra_isize
    			- new_extra_isize, (void *)raw_inode +
    			EXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,
    			(void *)header, total_ino);
    	EXT4_I(inode)->i_extra_isize = new_extra_isize;
```
<br>

```c
<clean up>
      cleanup:
	if (error && (mnt_count != le16_to_cpu(sbi->s_es->s_mnt_count))) {
		ext4_warning(inode->i_sb, "Unable to expand inode %lu. Delete some EAs or run e2fsck.",
			     inode->i_ino);
		mnt_count = le16_to_cpu(sbi->s_es->s_mnt_count);
	}
	return error;
}
```
----
## `ext4_xattr_free_space` 분석

```c
/*
 * Find the available free space for EAs. This also returns the total number of
 * bytes used by EA entries.
 */
static size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,
				    size_t *min_offs, void *base, int *total)
{
	for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
		if (!last->e_value_inum && last->e_value_size) {
			size_t offs = le16_to_cpu(last->e_value_offs);
			if (offs < *min_offs)
				*min_offs = offs;
		}
		if (total)
			*total += EXT4_XATTR_LEN(last->e_name_len);
	}
	return (*min_offs - ((void *)last - base) - sizeof(__u32));
}

__le32	e_value_inum;	/* inode in which the value is stored */
__le32	e_value_size;	/* size of attribute value */
__le16	e_value_offs;	/* offset in disk block of value */

 ```
 `Extended Attributes`는 이름:값 쌍으로 이루어지며, 파일과 디렉터리와 연관되는 기본 속성을 확장시킨 것이다. <br> 예를 들어, 파일의 접근 권한, 생성시간, 최근 변경 시간 등의 정보이다.<br>

 <br>



----

## `ext4_xattr_make_inode_space` 분석

```c
<ext4_xattr_make_inode_space>

static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,
				       struct ext4_inode *raw_inode,
				       int isize_diff, size_t ifree,
				       size_t bfree, int *total_ino)
{
	struct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);
	struct ext4_xattr_entry *small_entry;
	struct ext4_xattr_entry *entry;
	struct ext4_xattr_entry *last;
	unsigned int entry_size;	/* EA entry size */
	unsigned int total_size;	/* EA entry size + value size */
	unsigned int min_total_size;
	int error;
 ```
<br>

`ext4_xattr_make_inode_space`에는 위와 같은 인자들이 선언되어있다.<br>

`ifree`가 할당해줘야 하는 isize보다 작다면 EA 블록에 최적화된 entry를 찾는다.<br>

```c
while (isize_diff > ifree) {
  entry = NULL;
  small_entry = NULL;
  min_total_size = ~0U;
  last = IFIRST(header);
  for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
    total_size = EXT4_XATTR_LEN(last->e_name_len);
    if (!last->e_value_inum)
      total_size += EXT4_XATTR_SIZE(
               le32_to_cpu(last->e_value_size));
    if (total_size <= bfree &&
        total_size < min_total_size) {
      if (total_size + ifree < isize_diff) {
        small_entry = last;
      } else {
        entry = last;
        min_total_size = total_size;
      }
    }
  }
 ```

 ```c
 entry_size = EXT4_XATTR_LEN(entry->e_name_len);
 total_size = entry_size;
 if (!entry->e_value_inum)
   total_size += EXT4_XATTR_SIZE(
             le32_to_cpu(entry->e_value_size));
 error = ext4_xattr_move_to_block(handle, inode, raw_inode,
          entry);
 if (error)
   return error;

 *total_ino -= entry_size;
 ifree += total_size;
 bfree -= total_size;
 ```

---

## `ext4_xattr_set_entry` 분석

```c
last = s->first;
for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
  if (!last->e_value_inum && last->e_value_size) {
    size_t offs = le16_to_cpu(last->e_value_offs);
    if (offs < min_offs)
      min_offs = offs;
  }
}
```
<br>
이 부분이 해당 취약점이 발견되면서 패치 된 부분이다.<br>

last가 ext4_xattr_search의 fisrt값이 들어가고 함수가 진행 되는데,`lost+found`가 `buffer_verified flag`가 set이 되어있어서 참조를 하게 된다.<br>

`lost+found`는 `xattr entry`가 아닌 다른 entry이다.<br>


따라서 EXT4_XATTR_NEXT의 `e_name_len`의 값이 변하면서 for문이 진행되면서 next entry를 참조하다가 boundary를 넘어가서 `Out of bounds`나 `Use-After-Free`같은 취약점이 발생하게 된다.<br>

이제 1-day분석은 어느정도 된것 같아서 1-day exploit을 연습할 예정이다.<br>

## END.

----
