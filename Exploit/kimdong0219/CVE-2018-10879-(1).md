CVE-2018-10879
==============

### Use After-free detected by KASAN in Ext4

#### **<POC.C>**

```c
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <dirent.h>
#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <linux/falloc.h>
#include <linux/loop.h>
static void activity(char *mpoint) {
char *foo_bar_baz;
char *foo_baz;
int err;
err = asprintf(&foo_bar_baz, "%s/foo/bar/baz", mpoint);
err = asprintf(&foo_baz, "%s/foo/baz", mpoint);
rename(foo_bar_baz, foo_baz);
}
int main(int argc, char *argv[]) {
activity(argv[1]);
return 0;
}
```

<br>

---

### **Comment**

```
block 35는 block allocation bitmap으로 사용 된다.
```

**Block allocation이란?** <br>

모든 read-write 파일 시스템들은 파일에 배치할 때 문제가 발생한다. <br>

개별적으로 해결되야할 두가지 문제들이 존재한다. <br>

-	`free Block`을 찾는 과정 <br>
-	특정 파일의`데이터가 저장 되어있는` 블록을 기억하는 과정<br>

`extent`는 블록의 range를 첫번째 블록의 숫자와 블록의 range 길이를 명시한다.<br>

위 두가지 문제점들의 대안은 각 블록의 번호를 따로 보관하는 것인데, 보통은 더 많은 공간이 필요하지만 간단하다.<br>

그래서 많은 파일 시스템들은 `allocation bitmap`을 사용한다.<br>

파일을 구성하는 블록을 저장하는 전통적인 UNIX방법은 extent를 사용하지 않고 블록 번호 목록을 사용한다.<br>

처음에는 inode 구조에 저장된다.(direct block)<br>

이 공간이 차게 되면 한 블록이 추가 블록 번호를 저장하도록 할당 된다.<br>

이 간접 블록의 블록 번호만 inode구조에 저장된다.<br>

그 공간도 소진될시 이 방법을 반복적으로 적용하여 이중 간접 블록 또는 삼중 간접 블록으로 이어진다.<br>

**CVE-2018-10879**에서는 block 35번이 `allocation bitmap`으로 사용 되고 있다.<br>

그리고 그 블럭은 `buffer_verified flag`가 set되어 있다.<br>

그후에 `ext4_xattr_check_block()``을 호출 할시, code는`buffer_verified flag`를 체크하고 확인된 블록이라고 판단한다. 그에 따라 2가지 패치를 한다.<br>

**(1) ext4: add corruption check in ext4_xattr_set_entry()**<br>&nbsp;&nbsp;&nbsp; <b>http://patchwork.ozlabs.org/patch/928666/<br>**(2) ext4: always verify the magic number in xattr blocks** <br>&nbsp;&nbsp;&nbsp; <b>http://patchwork.ozlabs.org/patch/928667/<br>

---

### **Patch**

(1) xattr 버퍼를 `overrun`하지 않는지 확인하는 추가적인 체크를 추가했다.<br>

```c
static int ext4_xattr_set_entry(struct ext4_xattr_info *i,handle_t *handle, struct inode *inode, bool is_block)
{
 -struct ext4_xattr_entry *last;
 +struct ext4_xattr_entry *last, *next;
 struct ext4_xattr_entry *here = s->here;
 size_t min_offs = s->end - s->base, name_len = strlen(i->name);
 int in_inode = i->in_inode;
 static int ext4_xattr_set_entry(struct ext4_xattr_info *i,

    /* Compute min_offs and last. */
 last = s->first;
 -for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
 +for (; !IS_LAST_ENTRY(last); last = next) {
 +  next = EXT4_XATTR_NEXT(last);
 +  if ((void *)next >= s->end) {
 +          EXT4_ERROR_INODE(inode, "corrupted xattr entries");
 +          ret = -EFSCORRUPTED;
 +          goto out;
 ...
 +      }
```

(2) inode가 block allocation bitmap같은 다른 종류의 메타데이터 블록을 가리키는 경우에도,`buffer_verified flag`가 set될수 있다<br>

이러한 경우 외부의 attribute block을 만들수 있다.<br>

`verified flag`를 사용하는 이유는 지속적으로 재검증을 막기 위해서이다.<br>

하지만 xattr block의 `magic number`를 확인하는 작업은 많은 overhead가 걸리지 않고 `potential crash`들을 피할수 있다.<br>

```c
__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh)
 {
    int error = -EFSCORRUPTED;

-   if (buffer_verified(bh))
-       return 0;
-
    if (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
        BHDR(bh)->h_blocks != cpu_to_le32(1))
        goto errout;
+   if (buffer_verified(bh))
+       return 0;
+
    error = -EFSBADCRC;
    if (!ext4_xattr_block_csum_verify(inode, bh))
        goto errout;
    ...
  }
```
