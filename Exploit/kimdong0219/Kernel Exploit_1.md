
# Linux Kernel Exploit Development 1

<br>

## Task 1

```c
Master VM - root : 123456
Ubuntu Test VM - test : 123456
```

 Test VMware의 `.vmx`파일에 다음을 옵션을 추가해 준다.
```c
debugStub.listen.guest64 = "TRUE"
debugStub.listen.guest64.remote = "TRUE"
```
첫번째 옵션은 두번째 옵션이 gdb server를 Loopback 뿐만 아닌 모든 인터페이스에 열어줄때  `gdbstub`가  가능하게 해준다.<br>
 이 옵션은 커널에 원격으로 붙을 때 필요하다.<br>

추가적으로 serial port를 만들기위해 아래 옵션을 넣어준다.
```c
serial1.present = "TRUE"
serial1.fileType = "file"
serial1.fileName = "your_fs_path_here" // MasterVM에 /tmp/test/폴더를 넣어줌
 ```

마지막으로 testVM을 부팅 시킨 다음 `/boot/grub/grub.cfg`에 아래 옵션을 넣어준다
```C
107 #linux /vmlinuz-3.5.0-23-generic root=/dev/mapper/ubuntu-root ro
108 linux /vmlinuz-3.5.0-23-generic root=/dev/mapper/ubuntu-root ro console=ttyS1,115200n8 nosmep nosmap
109 initrd /initrd.img-3.5.0-23-generic
 ```
위의 설정을 마친 후에 재시작을 한다.<br>
부팅이 되면 다음 명령어로 `no smep no smap`이 되어있는지 확인한다.
 ```sh
 cat /proc/cpuinfo | grep -E ’sm[e|a]p’
 ```
 <br>

 ------
## Task 2

 Master VM에서 Host VM으로 `8864 Port`로 접속이 되는지 확인한다.<br>
 Master VM IP가 192.168.40.143이라 가정했을때, Host VM IP가 192.168.40.1이 된다.<br>

  ```sh
 root@master:˜# nc -vv 192.168.40.1 8864
192.168.40.1: inverse host lookup failed: Unknown host
(UNKNOWN) [192.168.40.1] 8864 (?) open
sent 0, rcvd 0
 ```
 만약 port 가 닫혀 있거나 host가 `unreachable`이라면 Task1 과정을 다시 한다.<br>
 다음으로 gdb로 원격 접속을 한다.<br>

  ```sh
  root@master:˜# gdb -q kernels/vmlinux-3.5.0-23-generic
  Reading symbols from kernels/vmlinux-3.5.0-23-generic...done.
  (gdb) target remote 192.168.40.1:8864
  Remote debugging using 192.168.40.1:8864
  native_safe_halt () at /build/buildd/linux-lts-quantal-3.5.0/arch/x86/include/asm/
  irqflags.h:50
  warning: Source file is more recent than executable.
  50 }
 ```
 <br>

 ---
## Task 3
Task 3는 Exercise이다. <br>
VMtest에 `./exercises/syscall_bp/trigger.c`가 들어있다.
```c
#include <stdio.h>
int main() {
printf("test\n");
return 0;
}
```
 **목표 : trigger code를 컴파일 하고 breakpoint를 sys_write에 걸고 test를 1337으로 출력 값을 바꿔준다.**<br>

 ### pwndbg 설치
 ```sh
 git clone https://github.com/pwndbg/pwndbg; cd pwndbg;
 ```
 ```sh
 ./setup.sh
 ```
 setup.sh를 실행 시키면 sudo 오류와 libssl 오류가 발생한다.
 다음 명령어로 3가지를 설치해 주어야 한다.<br>
 ```sh
 apt-get install sudo
 apt-get install libssl1.0.0
 apt-get install libssl-dev
 ```
 ### trigger.c 분석
<br>

**C 코드**

```c
#include <stdio.h>
int main() {
printf("test\n");
return 0;
}
```
<br>

**Assem**
```c
0x00000000004004f4 <+0>:	push   rbp
0x00000000004004f5 <+1>:	mov    rbp,rsp
0x00000000004004f8 <+4>:	mov    edi,0x4005fc
0x00000000004004fd <+9>:	call   0x4003f0 <puts@plt>
0x0000000000400502 <+14>:	mov    eax,0x0
0x0000000000400507 <+19>:	pop    rbp
0x0000000000400508 <+20>:	ret
```
 `mov edi, 0x4005fc`의 0x4005fc는 printf를 해줄 인자의 주소값이다.<br>

 * x/x  : 16진수 출력<br>

 * x/s  : string 출력<br>

 * x/xg : 64 bit 출력<br>

```c
(gdb) x/s *0x4005fc
0x74736574:	 <Address 0x74736574 out of bounds>
 ```

 ```c
(gdb) x/s 0x4005fc
0x4005fc:	 "test"
 ```
따라서 breakpoint를 `main+4`에 걸어주고 `edi`값을 변경해보자<br>

```c
(gdb) b *main+4
(gdb) r
(gdb) i r edi
edi            0x1	1
(gdb) ni
(gdb) i r edi
edi            0x4005fc	4195836
(gdb) set *$edi=0x0a37333331
(gdb) c
Continuing.
1337
 ```

 **출력값이 test에서 `1337`로 변경되었다**<br>

 ### 원격 trigger.c 분석

`disas sys_write`를 MasterVM에서 해본다.
```c
0xffffffff81187e10 <+0>:	push   rbp
0xffffffff81187e11 <+1>:	mov    rbp,rsp
0xffffffff81187e14 <+4>:	sub    rsp,0x40
0xffffffff81187e18 <+8>:	mov    QWORD PTR [rbp-0x18],rbx
0xffffffff81187e1c <+12>:	mov    QWORD PTR [rbp-0x10],r12
0xffffffff81187e20 <+16>:	mov    QWORD PTR [rbp-0x8],r13
0xffffffff81187e24 <+20>:	nop    DWORD PTR [rax+rax*1+0x0]
0xffffffff81187e29 <+25>:	mov    r12,rsi
0xffffffff81187e2c <+28>:	lea    rsi,[rbp-0x24]
0xffffffff81187e30 <+32>:	mov    r13,rdx
0xffffffff81187e33 <+35>:	call   0xffffffff81189040 <fget_light>
0xffffffff81187e38 <+40>:	test   rax,rax
0xffffffff81187e3b <+43>:	mov    rbx,rax
0xffffffff81187e3e <+46>:	je     0xffffffff81187e90 <sys_write+128>
0xffffffff81187e40 <+48>:	mov    rax,QWORD PTR [rax+0x40]
0xffffffff81187e44 <+52>:	lea    rcx,[rbp-0x30]
0xffffffff81187e48 <+56>:	mov    rdx,r13
0xffffffff81187e4b <+59>:	mov    rsi,r12
0xffffffff81187e4e <+62>:	mov    rdi,rbx
0xffffffff81187e51 <+65>:	mov    QWORD PTR [rbp-0x30],rax
0xffffffff81187e55 <+69>:	call   0xffffffff81187a80 <vfs_write>
0xffffffff81187e5a <+74>:	mov    r9d,DWORD PTR [rbp-0x24]
0xffffffff81187e5e <+78>:	mov    rdx,QWORD PTR [rbp-0x30]
0xffffffff81187e62 <+82>:	test   r9d,r9d
0xffffffff81187e65 <+85>:	mov    QWORD PTR [rbx+0x40],rdx
0xffffffff81187e69 <+89>:	je     0xffffffff81187e7b <sys_write+107>
0xffffffff81187e6b <+91>:	mov    rdi,rbx
0xffffffff81187e6e <+94>:	mov    QWORD PTR [rbp-0x38],rax
0xffffffff81187e72 <+98>:	call   0xffffffff81188c80 <fput>
0xffffffff81187e77 <+103>:	mov    rax,QWORD PTR [rbp-0x38]
0xffffffff81187e7b <+107>:	mov    rbx,QWORD PTR [rbp-0x18]
0xffffffff81187e7f <+111>:	mov    r12,QWORD PTR [rbp-0x10]
0xffffffff81187e83 <+115>:	mov    r13,QWORD PTR [rbp-0x8]
0xffffffff81187e87 <+119>:	leave
0xffffffff81187e88 <+120>:	ret
0xffffffff81187e89 <+121>:	nop    DWORD PTR [rax+0x0]
0xffffffff81187e90 <+128>:	mov    rax,0xfffffffffffffff7
0xffffffff81187e97 <+135>:	jmp    0xffffffff81187e7b <sys_write+107>
```
**sys_write +48에 breakpoint를 걸어본다.**<br>
모든 출력에 break가 걸려서 문제가 발생한다.<br>
따라서 TestVM에서 `./trigger`를 하기 직전에 bp를 걸어주고 실행을 시킨다.<br>
![gdb](https://i.imgur.com/LgX4WOX.png)

다음과 같이 breakpoint에서 멈추게 된다.<br>
**gdb intel 명령어 : set disassembly-flavor intel**<br>
문제 해결을 위해 sys_write의 코드를 보자
<b> https://elixir.bootlin.com/linux/v4.5/source/include/linux/syscalls.h#L567 <br>

```c
sys_write(unsigned int fd, const char __user *buf,size_t count);
```
<br>

sys_write에는 3가지 인자가 들어가는데 calling convention을 보자<br>

리눅스는 64비트 모드에서 파라미터를 전달할 때 레지스터를 많이 사용한다.<br>
정수 타입의 파라미터를 전달할 때는 순서대로 RDI,RSI,RDX,RCX,R8,R9까지 6개의 레지스터를 사용하고 7개 이상이면 스택을 통해 전달한다.<br>
![calling](https://i.imgur.com/mIU04zr.png)<br>


**sys_write에서는 buf값을 변경시켜주어야 하는데 buf값은 rsi에 들어가게 된다.**<br>
다시 gdb로 돌아와서 sys_write+65에 bp를 걸고 확인해보자.

```c
pwndbg> x/s $rsi
0x20a0008:	"\n/triggertu:~/exercises/syscall_bp$ nd\nnd\nnd\n\nfication\nn\nn\nification\n\non\n\n", '\337' <repeats 125 times>, <incomplete sequence \337>...
```
$rsi 값을 확인해보면 개행처리 때문에 다른 값이 들어가있다.
```c
pwndbg> c
pwndbg> x/s $rsi
0x7fafca9c0000:	"test\n"
```
continue를 한번 해주고 $rsi값을 확인해주면 test가 들어있는것을 볼수있다.<br>
따라서 rsi 값을 1337로 변경해주자 1337은 ASCII코드(little endian)로 0x(0a)37333331이 된다.<br>

```c
pwndbg> set *$rsi=0x0a37333331
pwndbg> c
```
![1337](https://i.imgur.com/8LYzOGf.png)

**1337이 나오는 것을 볼수 있다**<br><br>

##END.

----
