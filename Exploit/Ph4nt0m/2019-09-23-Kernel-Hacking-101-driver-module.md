---
title: Kernel Hacking 101 driver module
description: printk overwrite in module
header: Kernel Hacking 101 driver module
---

### Introduction

Lodable Kernel Module(LKM)은 실행중인 커널을 확장하는 코드가 포함된 객체 파일이다.
예를 들어, 디바이스 드라이버는 종종 외부 모듈로 컴파일 되거나 로드되며 필요한 때만 로드된다.
어떤 모듈은 커널 시작시에 로드되기도 하며 특정 기능이 요청될때 로드되기도 한다.(e.g., 특정 프로토콜을 사용한 소켓을 생성할때).

취약한 모듈이 로드되면 모듈 및 커널의 다른 정적 부분의 취약점을 익스플로잇하는데 차이가 없다.

우리는 ./exercises/mod_sample안에 있는 커널 모듈을 로드하고 디버깅할 것이다.

이 샘플 드라이버는 레지스터 /dev/sample 문자 device를 등록하고 장치에서 open/close/read를 위한 몇가지 operation을 구현한다.

샘플 모듈은 TestVM1에서 로드할 수 있다(/exercises/mod_sample/sample.ko)(root required).
디바이스가 로드되면 open/close/read를 디바이스에서 device_open/close/read 함수로 각각 핸들링 할 수 있다.

```C
...
static int device_open(struct inode *inode, struct file *file) {
  if (dev_counter)
    return -EBUSY;
  dev_counter++;
  return 0;
}
static int device_close(struct inode *inode, struct file *f) {
  dev_counter--;
  return 0;
}
static ssize_t device_read(struct file *file, char *buf, size_t size, loff_t \*off)
{
  char tmp[5] = "test";
  printk(KERN_INFO "%s\\n", tmp);
  return 0;
}
...
```

device_read()함수로 sample char device를 읽을때, tmp buffer의 값을 커널 콘솔 로그로 출력해준다.

![img](/img/2019-09-23_1.png)
<br><br><br>


### Debug Load
syscall overwrite했을때와 목표는 비슷하다. 그러나 BP가 로드된 커널의 모듈이다.
모듈을 로드하고 .text, .data, .bss 주소를 디버거에 맞춘다.

![img](/img/2019-09-23_2.png)
<br><br><br><br>

MasterVM에서 심볼을 로드한다.

![img](/img/2019-09-23_3.png)
<br><br><br><br><br><br>

MasterVM과 TestVM1에서 모듈 컴파일 경로가 다르므로 gdb에서 올바르게 로드하라.
이게 생각보다 귀찮은 작업이다. MasterVM에서는 root에서 실행하기 때문에 경로를 변경해야한다. 드라이버 소스 안에 있는 Author는 고쳐야하는건지 아닌지는 잘 모르겠다.

User Space에서 device_read에 BP를 걸로 trigger해라. 그럼 gdb에서 소스와 각 context를 나누어서 보여준다. "test"를 "thisisaverylongstring\n"으롷 바꿔 출력하라.
x64 calling_convention에 의해 printk함수에 들어가는 버퍼 포인터는 rdi 이다.

UserSpace에 문자열을 작성한 다음 gdb에서 인자를 userspace address에 설정할 수 있다.

음.... 너무 거창하게 설명한것 같다.
![img](/img/2019-09-23_4.png)
<br><br><br><br><br><br>

printk함수의 출력을 "thistisaverylongstring\n" 으로 바꾸란 것이다.
지금 사용하는 함수 형태를 보니 인자가 3개 들어가는 것 같 tmp의 주소를 다른곳으로 리다이렉트하거나 tmp안의 값을 위의 문자열로 바꾸면 되지 않을까 생각한다.

그러나 "thisisaverylongstring\n"은 많이 긴 문자열이다.
단순히 set 명령으로 인라인패치를 하기엔 데이터가 바이트 오더에 맞게 들어가지않는다.

그래서 생각한 것은 userspace의 bss를 이용하는 것이다.
bss영역에 "thisisaverylongstring"을 저장한다.

![img](/img/2019-09-23_5.png)
<br><br><br><br>

![img](/img/2019-09-23_6.png)
<br><br><br><br>

이후 2번째 인자인 rsi를 bss의 주소로 바꿔주면 bss의 값을 출력할것이다.
![img](/img/2019-09-23_7.png)
<br><br><br><br>
![img](/img/2019-09-23_8.png)
<br><br><br><br><br><br>
![img](/img/2019-09-23_9.png)
<br><br><br><br>

#Exploit Success!!
