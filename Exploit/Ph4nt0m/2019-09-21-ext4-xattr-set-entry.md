---
title: CVE-2018-10840 Analysis
description: CVE-2018-10840 ext4_xattr_set_entry buffer overflow Analysis
header: CVE-2018-10840 ext4_xattr_set_entry Analysis
---
이 취약점은 removexattr 함수 내의 ext4_xattr_set_entry 함수 내에서 memmove함수의 길이값 오류로 터지는 BOF?취약점이다.

파일들의 xattr들을 봤는데 모두 empty로 비어있었다.


## 1.Crash Func : ext4_xattr_set_entry
디버깅한 모습은 다음과 같다.

![img](/img/2019-09-21_1.png)
<br><br><br><br><br><br><br><br>

rax : [rsp+0x20] -> 0x400
rsi : [rsp+0x10] -> 0x0
rdx : 0x3f4(1012)

r14 : rax -> 0x400, r14 : r14 + 0xffff880079e7500 -> 0xffff880079e75400
rdx : rdx - rax -> 0x3f4 - 0x400 = -0xc(12)
rdi : [r14 + rsi] == &rax
rsi : mov r14 -> 0xffff880079e75400

call memmove(0xffff880079e75400, 0xffff880079e75400, -12)

![img](/img/2019-09-21_2.png)  
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
이렇기 때문에 이 부분에서 Crash가 터지는 것이다.

![img](/img/2019-09-21_3.png)  
<br><br><br><br><br><br><br>
그렇다면 memmove의 인자인 first_val + old_size, first_val, val - first_val의 값들이 어떻게 설정되는지 봐야 겠다.

## 2.Back Trace
### vfs_removexattr - remove_xattr_via_vfs

![img](/img/2019-09-21_4.png)  
<br><br>

~~vfs_removexattr(d, kname)의 매개변수중에 d의 값은 잘 모르겠으나 device 번호? 로 추측된다.~~

vfs_removexattr(d, kname) d는 dentry 주소,

kname은 user.mime_type으로 설정되어 있다.

### ext4_xattr_set_handle

![img](/img/2019-09-21_6.png)

ext4_xattr_set_handle(handle, inode, name_index, name, value, value_len, flags)의 형태로 되어 있는데 함수의 설명은 이렇다.
이 inode에 대한 확장속성을 create/replace/remove하는 함수
기존 xattr을 제거하려면 값이 NULL, Replace하거나 remove하려면 NULL이 아니어야 한다.
실패시에 0 또는 음수를 return 한다.

### ext4_xattr_set_entry

![img](/img/2019-09-21_7.png)

ext4_xattr_set_entry(struct ext4_xattr_info \*i, struct ext4_xattr_search \*s, \\
handle_t \*handle, struct inode \*inode, bool is_block)

```C
ext4_xattr_set_entry 함수로 진입 전의 인자값은 다음과 같다.
xattr_info *i : 'mime_type'(ext4_xattr_info)
xattr_search *s : 주소값(ext4_xattr_search)
handle_t *handle : 0x30
inode : 0xd81a4
is_block : 1
```

### Again ext4_xattr_set_entry

![img](/img/2019-09-21_8.png)  
<br><br><br><br><br><br>
이제 memmove 직전에 계산되는 값들을 볼 것이다.

이 값들은 함수 시작 전에 push되는 값들은 함수의 매개변수들이다.  
r15 : is_block(0x1)  
r14 : inode(0xd81a4)  
r13 : handle's address(0xffffc900006efb28)  
r12 : xattr_search's address(0xffffc90000763b20)  
rbx : xattr_info(mime_type(0xffffc90000763b10))  

![img](/img/2019-09-21_13.png)
![img](/img/2019-09-21_9.png)  
<br><br><br><br><br><br><br><br><br><br><br>
```C
s->base = 0xffff880079e83000
s->end = 0xffff880079e83400
size_t min_offs = s->end - s->base = 0x400
```

![img](/img/2019-09-21_14.png)
old_size는 모두 조건이 참이지만 here->e_value_size가 0이라 0으로 할당되고
new_size는 i->value가 0이므로 조건문에 의해 0이 할당된다.

![img](/img/2019-09-21_10.png)
![img](/img/2019-09-21_11.png)  
<br><br><br><br><br><br><br>

```C
first_val = s->base - min_offs = 0xffff880079ee4400
offs = here->e_value_offs = 0x3f4

val = s->base + offs = 0xffff880079e83000 + 0x3f4 = 0xffff880079e833f4

val - first_val = 0xffff880079e833f4 - 0xffff880079ee4400 = 0xfffffffffff9eff4
memmove(first_val(0xffff880079ee4400) + old_size(0), first_val, (val - first_val)(-397324))
함수의 크래시는 이곳에서 난다.
첫번째의 인자값과 두번째 인자값은 같으며(first_val + old_size == first_val)
길이 값은 -397324로 memmove 함수에서 크래시가 난다.
```
~~때문에 만약 first_val 함수의 변조가 가능하다면 다른 Control Flow로도 분기시킬 수 있지 않을까 생각한다.~~
