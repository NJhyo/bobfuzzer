---
title: Kernel Hacking 101 syscall overwrite
description: sys_write overwrite
header: Kernel Hacking 101 syscall overwrite
---

```C
#include <stdio.h>

int main(){
        printf("test\n");

        return 0;
}
```

여기 아주 간단한 printf 소스가 있다.

이것을 'test'가 아닌 '1337'로 출력하려 한다.

sys_write 함수를 조작하여 '1337'을 출력하라.

우선 MasterVM에서 vmlinux 파일을 gdb에 붙이고 remote 디버깅을 준비한다.

![img](/img/2019-09-22_1.png)
<br><br><br><br><br><br>



그리고 sys_write에 bp를 걸면 testVM에서 출력(stdout)하려는 동작마다 모든 break가 걸린다.

그렇기에 실행 직전에 break point를 걸고 위의 프로그램을 실행한다.

![img](/img/2019-09-22_2.png)  
<br><br>

![img](/img/2019-09-22_3.png)  
<br><br>

```C
asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);
```
sys_write함수의 원형은 이렇다.
arg1 : file descriptor
arg2 : char* buf
arg3 : size_t buf_len

두번째 인자 포인터 내의 값만 바꿔주면 끝난다.

그러나 위에서 말했듯이 sys_write는 모든 stdout에 bp가 걸린다.
따라서 프로그램이 개행되는 출력과, 문자가 출력되는 출력 2단계에 걸쳐서 프로그램이 실행되므로 첫번째 sys_write는 pass 한다.

```C
0xffffffff81187e10 <+0>:	push   rbp
0xffffffff81187e11 <+1>:	mov    rbp,rsp
0xffffffff81187e14 <+4>:	sub    rsp,0x40
0xffffffff81187e18 <+8>:	mov    QWORD PTR [rbp-0x18],rbx
0xffffffff81187e1c <+12>:	mov    QWORD PTR [rbp-0x10],r12
0xffffffff81187e20 <+16>:	mov    QWORD PTR [rbp-0x8],r13
0xffffffff81187e24 <+20>:	nop    DWORD PTR [rax+rax*1+0x0]
0xffffffff81187e29 <+25>:	mov    r12,rsi
0xffffffff81187e2c <+28>:	lea    rsi,[rbp-0x24]
0xffffffff81187e30 <+32>:	mov    r13,rdx
0xffffffff81187e33 <+35>:	call   0xffffffff81189040 <fget_light>
0xffffffff81187e38 <+40>:	test   rax,rax
0xffffffff81187e3b <+43>:	mov    rbx,rax
0xffffffff81187e3e <+46>:	je     0xffffffff81187e90 <sys_write+128>
0xffffffff81187e40 <+48>:	mov    rax,QWORD PTR [rax+0x40]
0xffffffff81187e44 <+52>:	lea    rcx,[rbp-0x30]
0xffffffff81187e48 <+56>:	mov    rdx,r13
0xffffffff81187e4b <+59>:	mov    rsi,r12
0xffffffff81187e4e <+62>:	mov    rdi,rbx
0xffffffff81187e51 <+65>:	mov    QWORD PTR [rbp-0x30],rax
0xffffffff81187e55 <+69>:	call   0xffffffff81187a80 <vfs_write>
0xffffffff81187e5a <+74>:	mov    r9d,DWORD PTR [rbp-0x24]
0xffffffff81187e5e <+78>:	mov    rdx,QWORD PTR [rbp-0x30]
0xffffffff81187e62 <+82>:	test   r9d,r9d
0xffffffff81187e65 <+85>:	mov    QWORD PTR [rbx+0x40],rdx
0xffffffff81187e69 <+89>:	je     0xffffffff81187e7b <sys_write+107>
0xffffffff81187e6b <+91>:	mov    rdi,rbx
0xffffffff81187e6e <+94>:	mov    QWORD PTR [rbp-0x38],rax
0xffffffff81187e72 <+98>:	call   0xffffffff81188c80 <fput>
0xffffffff81187e77 <+103>:	mov    rax,QWORD PTR [rbp-0x38]
0xffffffff81187e7b <+107>:	mov    rbx,QWORD PTR [rbp-0x18]
0xffffffff81187e7f <+111>:	mov    r12,QWORD PTR [rbp-0x10]
0xffffffff81187e83 <+115>:	mov    r13,QWORD PTR [rbp-0x8]
0xffffffff81187e87 <+119>:	leave
0xffffffff81187e88 <+120>:	ret
```

이것이 sys_write 함수의 어셈 코드이다. 우리가 볼 곳은 vfs_write 함수가 call되기 이전의 인자들을 보고 바꿀 생각이다.

![img](/img/2019-09-22_4.png)  
<br>

![img](/img/2019-09-22_5.png)  
<br><br><br><br><br>

개행 출력을 지난 후의 어셈 코드이다.
어셈 코드를 C로 표현하면 다음과 같다.

```C
rax = *rax+0x40
rcx = &rbp - 0x30
rdx = r13
rsi = r12
rdi = rbx
*rbp-0x30 = rax
call vfs_write(rdi, rsi, rdx)
```
이제 값을 보자.

![img](/img/2019-09-22_6.png)  
<br><br><br>

두번째 인자인 rsi의 주소 안에 'test\n'이라는 값이 저장되어 있다.
rsi 주소 안의 값을 '1337\n'로 바꿔주면 출력을 1337로 할 것이다.

![img](/img/2019-09-22_7.png)  
<br>

![img](/img/2019-09-22_8.png)  
<br><br><br><br>
값이 바뀌었다!! 이제 결과를 보자

![img](/img/2019-09-22_9.png)  
<br><br>

Exploit Success!!
