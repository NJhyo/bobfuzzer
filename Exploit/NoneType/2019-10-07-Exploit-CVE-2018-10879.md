---
layout: post
title: "malloc.c Analysis"
author: "nonetype"
---

# 목차

1. TOC
{:toc}

---

# Vulnerability Analysis
해당 취약점은 `lost+found entry`가 `allocation bitmap`으로 확인되어 `buffer_verified` 플래그가 설정되고, `ext4_rename` 함수 내에서 `old_dentry`를 삭제하는 과정 중, 적합한 사이즈의 `xattr entry`를 찾으려 파일 시스템 내의 엔트리를 순회하는 중 `lost+found entry`가 `xattr entry`가 아님에도 불구하고 `buffer_verified` 플래그 체크가 되어있으므로 `xattr entry`로 오인되어 해당 엔트리 영역을 search하고, 해당 영역에 존재하는 스프레잉 된 값 `offset`으로 참조하여 다음 `Entry`를 찾으므로 연결 리스트의 offset이 heap 메모리에 할당된 `[s->base] ~ [s->end]` 영역을 벗어나 다른 커널 오브젝트를 참조함으로써 발생하는 `Slab-OOB` 취약점이다.

## ext4_xattr_block_find()
순회 중 참조하는 `ext4_xattr_block_find->ext4_xattr_search` 구조체는 `ext4_xattr_block_find()` 함수에서 필드 값을 채워준다.


```c
static int
ext4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,
		      struct ext4_xattr_block_find *bs)
{
		bs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);
                ...
                ...
		/* Find the named attribute. */
		/*
		#define BHDR(bh) ((struct ext4_xattr_header *)((bh)->b_data))
		*/
		bs->s.base = BHDR(bs->bh);
		/*
		#define BFIRST(bh) ENTRY(BHDR(bh)+1)
		*/
		bs->s.first = BFIRST(bs->bh);
		bs->s.end = bs->bh->b_data + bs->bh->b_size;
		bs->s.here = bs->s.first;
		error = xattr_find_entry(inode, &bs->s.here, bs->s.end,
					 i->name_index, i->name, 1);
		if (error && error != -ENODATA)
			goto cleanup;
		bs->s.not_found = error;
                ...
```

아래는 `bs->s.base = BHDR(bs->bh);` 코드가 실행되기 전 확인한 `bs`와 `bs->bh` 구조체 필드이다.
유의깊게 봐야 하는 점은, `bs->bh->b_state` 값이 `0x4000021`으로, `buffer_verified` 플래그(`0x4000000`)가 설정되었다는 것과 Heap 영역에 할당되는 구조체의 크기 `bs->bh->b_size`가 `0x400`이라는 점이다.

```sh
gef➤  p *$2
$3 = {
  s = {
    first = 0x0 <irq_stack_union>,
    base = 0x0 <irq_stack_union>,
    end = 0x0 <irq_stack_union>,
    here = 0x0 <irq_stack_union>,
    not_found = 0xffffffc3
  },
  bh = 0xffff88007bf714e0
}
gef➤  p *$2->bh
$4 = {
  b_state = 0x4000021,
  b_this_page = 0xffff88007bf71680,
  b_page = 0xffffea0001eaac80,
  b_blocknr = 0x23,
  b_size = 0x400,
  b_data = 0xffff88007aab2c00 "\002",
  b_bdev = 0xffff88007cc28340,
  b_end_io = 0x0 <irq_stack_union>,
  b_private = 0x0 <irq_stack_union>,
  b_assoc_buffers = {
    next = 0xffff88007bf71528,
    prev = 0xffff88007bf71528
  },
  b_assoc_map = 0x0 <irq_stack_union>,
  b_count = {
    counter = 0x2
  }
}
```

아래는 필드 할당 후의 구조체의 모습이다.
`bs->s->base`와 `bs->s->end`가 설정되어 Heap 영역에 할당된 구조체의 범위를 알 수 있었고, `first`와 `here` 필드가 `lost+found entry`를 가르키며, `NEXT(first)` 연산이 몇 차례 이루어지면 `0x9b9b9b9b` 영역을 참조할 수 있음을 알 수 있다.

```sh
gef➤  p *$2
$6 = {
  s = {
    first = 0xffff88007aab2c20,
    base = 0xffff88007aab2c00,
    end = 0xffff88007aab3000,
    here = 0xffff88007aab2c20,
    not_found = 0xffffffc3
  },
  bh = 0xffff88007bf714e0
}
gef➤  p *$2->bh
$5 = {
  b_state = 0x4000021,
  b_this_page = 0xffff88007bf71680,
  b_page = 0xffffea0001eaac80,
  b_blocknr = 0x23,
  b_size = 0x400,
  b_data = 0xffff88007aab2c00 "\002",
  b_bdev = 0xffff88007cc28340,
  b_end_io = 0x0 <irq_stack_union>,
  b_private = 0x0 <irq_stack_union>,
  b_assoc_buffers = {
    next = 0xffff88007bf71528,
    prev = 0xffff88007bf71528
  },
  b_assoc_map = 0x0 <irq_stack_union>,
  b_count = {
    counter = 0x2
  }
}

gef➤  x/128gx 0xffff88007aab2c00
0xffff88007aab2c00:	0x0201000c00000002	0x000000020000002e
0xffff88007aab2c10:	0x00002e2e0202000c	0x020a00140000000b
0xffff88007aab2c20:	0x756f662b74736f6c	0x0000000c0000646e
0xffff88007aab2c30:	0x006f6f660203000c	0x0201000c00000013
0xffff88007aab2c40:	0x0000005200000061	0x000000300101000c
0xffff88007aab2c50:	0x0101000c00000053	0x0000005400000031
0xffff88007aab2c60:	0x000000320101000c	0x0101000c00000055
0xffff88007aab2c70:	0x0000005600000033	0x000000340101000c
0xffff88007aab2c80:	0x0101000c00000057	0x0000005800000035
0xffff88007aab2c90:	0x000000360101000c	0xbabeccccbbaa0059
0xffff88007aab2ca0:	0xffffdeadbeefcafe	0x9b9b9b9b9b9bffff
0xffff88007aab2cb0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
0xffff88007aab2cc0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
0xffff88007aab2cd0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
...
0xffff88007aab2ff0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
0xffff88007aab3000:	0x0000000000000000	0x0000000000000000
```

## ext4_xattr_set_entry()

```
                                                       +--------------------+
                                                       |                    |
                                                       |                    |
                                                       |                    |
            ENTRY 01           ENTRY 02                |                    |
      +------------+-----+------------+-----+          |                    |
      |            |     |            |     |          |    OTHER OBJECT    |
      | e_name_len | ... | e_name_len | ... |          |                    |
      |            |     |            |     |          |                    |
      +------------+------------------+-----+          |                    |
      |                  ^                             |                    |
      |                  |                             |                    |
      |                  |                       +---->---------------------+
      +------------------+                       |     |                    |
                                                 |     |      ENTRY  N      |
    EXT4_XATTR_NEXT(ENTRY_01)                    |     |                    |
                                                 |     +--------------------+  <+ EXT4_XATTR_NEXT(ENTRY N-1)
((&ENTRY_01) + e_name_len + 0x0f)                |     |                    |
                                                 |     |      ENTRY N-1     |
                                                 |     |                    |
                                                 |     +--------------------+
                                                 |     *                    *
                                                 |     *                    *
                                                 |     *                    *
     struct ext4_xattr_search                    |     +--------------------+
                                                 |     |                    |
 +------------------------------+                |     |      ENTRY 03      |
 |            first             +-----+          |     |                    |
 +------------------------------+     |          |     +--------------------+ <+ EXT4_XATTR_NEXT(ENTRY 02)
 |            base              |     |          |     |                    |
 +------------------------------+     |          |     |      ENTRY 02      |
 |             end              +----------------+     |                    |
 +------------------------------+     |                +--------------------+ <+ EXT4_XATTR_NEXT(ENTRY 01)
 |            here              |     |                |                    |
 +------------------------------+     +--------------->+      ENTRY 01      |
 |          not_found           |                      |                    |
 +------------------------------+                      +--------------------+
31                            0
```



<!--
테스트 이미지 0xD0a0 위치에 data entry 존재. (0x44 )


gef➤  p *(struct ext4_xattr_entry *)0xffff8800799d04a4
$16 = {
  e_name_len = 0x4,
  e_name_index = 0x7,
  e_value_offs = 0x18,
  e_value_inum = 0x0,
  e_value_size = 0x44,
  e_hash = 0x0,
  e_name = 0xffff8800799d04b4 "data"
}


00 00 02 EA 04 07 18 00 00 00 00 00 44 00 00 00 00 00 00 00 64 61 74 61 00 00 00 00 0E 00 00 00 0C 00 03 01 68 6C 6E 00 12 00 00 00 38 00 03 07
��ê�����D�������data��������hln����8�


해당 값이 controlable? 조절 가능하면 대박쓰 안될가능성 높음
e_value_size는 체크 존재하는듯
-->

OOB Write되는 주소에 할당되있던 값은 다음과 같다.
syslog 관련 object로 추정되며, 각 오브젝트 크기는 `block`크기와 동일한 `0x400`이다.

```
gef➤  x/32gx 0xffff88007b773400
0xffff88007b773400:	0xffff88007b770c00	0x4f4c5359530a373d
0xffff88007b773410:	0x494c494341465f47	0x444f430a333d5954
0xffff88007b773420:	0x2e3d454c49465f45	0x64752f6372732f2e
0xffff88007b773430:	0x2d766564752f7665	0x0a632e73656c7572
0xffff88007b773440:	0x4e494c5f45444f43	0x430a363032323d45
0xffff88007b773450:	0x434e55465f45444f	0x6564753d4e4f4954
0xffff88007b773460:	0x5f73656c75725f76	0x6f745f796c707061
0xffff88007b773470:	0x530a746e6576655f	0x44495f474f4c5359
0xffff88007b773480:	0x5245494649544e45	0x646d65747379733d
0xffff88007b773490:	0x4d0a64766564752d	0x473d454741535345
0xffff88007b7734a0:	0x2f20352050554f52	0x766564752f62696c
0xffff88007b7734b0:	0x642e73656c75722f	0x766564752d30352f
0xffff88007b7734c0:	0x746c75616665642d	0x323a73656c75722e
0xffff88007b7734d0:	0x647562696c2f0a35	0x63697665642d7665
0xffff88007b7734e0:	0x2c3832313a632e65	0x6f6974636e756620
0xffff88007b7734f0:	0x645f76656475206e	0x65675f6563697665
```

이 값을 확인해보면, `400`위치에는 어떤 포인터가, `408` 위치부터는 문자열이 존재한다.

```
gef➤  x/s 0xffff88007b773408
0xffff88007b773408:	"=7\nSYSLOG_FACILITY=3\nCODE_FILE=../src/udev/udev-rules.c\nCODE_LINE=2206\nCODE_FUNCTION=udev_rules_apply_to_event\nSYSLOG_IDENTIFIER=systemd-udevd\nMESSAGE=GROUP 5 /lib/udev/rules.d/50-udev-default.rules:25\n/libudev-device.c:128, function udev_device_get_driver(). Ignoring.\n"
```

`400`위치의 포인터를 따라가 보면, 연결 리스트 형태로 각각의 로그 문자열을 참조하고 있음을 알 수 있다.
```
gef➤  x/gx 0xffff88007b770c00
0xffff88007b770c00:	0xffff88007b772000
gef➤  x/a 0xffff88007b770c00
0xffff88007b770c00:	0xffff88007b772000
gef➤  x/a 0xffff88007b772000
0xffff88007b772000:	0xffff88007b773800
gef➤  x/a 0xffff88007b773800
0xffff88007b773800:	0xffff88007b772c00
gef➤  x/a 0xffff88007b772c00
0xffff88007b772c00:	0xffff88007b770800
gef➤  x/a 0xffff88007b770800
0xffff88007b770800:	0xffff88007b770000
gef➤  x/a 0xffff88007b770000
0xffff88007b770000:	0xffff88007b771800
gef➤
0xffff88007b770008:	0x4f4c5359530a373d
gef➤
0xffff88007b770010:	0x494c494341465f47
gef➤
0xffff88007b770018:	0x444f430a333d5954
gef➤  x/s 0xffff88007b770008
0xffff88007b770008:	"=7\nSYSLOG_FACILITY=3\nCODE_FILE=../src/udev/udev-node.c\nCODE_LINE=344\nCODE_FUNCTION=udev_node_add\nSYSLOG_IDENTIFIER=systemd-udevd\nMESSAGE=handling device node '/dev/tty4', devnum=c4:4, mode=0620, uid=0, gid=5\n79290\nSystem Message Bus Socket.\nRESULT=done\n"
gef➤
```

이후 흐름을 쭉 따라갈 경우 `OOB Write`가 발생하여 아래와 같은 메모리 변경을 일으킨다.

```
gef➤  x/32gx 0xffff88007b773400
0xffff88007b773400:	0xcafebabedeadbeef	0xcafebabedeadbeef
0xffff88007b773410:	0x7b770c00deadbeef	0x530a373dffff8800
0xffff88007b773420:	0x41465f474f4c5359	0x333d5954494c4943
0xffff88007b773430:	0x49465f45444f430a	0x72732f2e2e3d454c
0xffff88007b773440:	0x752f766564752f63	0x656c75722d766564
0xffff88007b773450:	0x45444f430a632e73	0x32323d454e494c5f
0xffff88007b773460:	0x5f45444f430a3630	0x4e4f4954434e5546
0xffff88007b773470:	0x75725f766564753d	0x6c7070615f73656c
0xffff88007b773480:	0x6576655f6f745f79	0x4f4c5359530a746e
0xffff88007b773490:	0x49544e4544495f47	0x7379733d52454946
0xffff88007b7734a0:	0x6564752d646d6574	0x415353454d0a6476
0xffff88007b7734b0:	0x50554f52473d4547	0x2f62696c2f203520
0xffff88007b7734c0:	0x6c75722f76656475	0x2d30352f642e7365
0xffff88007b7734d0:	0x6665642d76656475	0x6c75722e746c7561
0xffff88007b7734e0:	0x6c2f0a35323a7365	0x642d766564756269
0xffff88007b7734f0:	0x3a632e6563697665	0x6e7566202c383231
gef➤
```

## 10/08 16:42
해당 구조체들은 모두 연결 리스트로 이루어져 있음.
각 구조체마다 위에 명시했듯 로그 문자열을 가지고 있으며, 가장 최근에 할당된 메모리에는 포인터가 NULL임.
따라서 새로운 로그 문자열이 할당될 때 우리가 적어준 주소의 포인터에 새로 할당한 로그 문자열 청크의 주소를 적어주는듯?

테스트 삼아 0x1234123412341234 위치에 할당 후 해당 주소 확인해보는걸로
