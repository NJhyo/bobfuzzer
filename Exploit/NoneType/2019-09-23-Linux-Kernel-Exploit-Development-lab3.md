---
layout: post
title: "Linux Kernel Exploit Development (Part 3/10)"
author: "nonetype"
---

Linux Kernel Exploit Development with VMware - Lab3::Privilege Escalation

---
# 목차



[1. Privilege Escalation](#privilege-escalation)


[2. do: LPE()](#do-lpe)


[3. Debug Kernel Module](#debug-kernel-module)

---

# Privilege Escalation
커널 권한 상승은 보통 두가지 방법을 통해 익스플로잇하게 된다.

1. `prepare_kernel_cred()`와 `commit_creds()` 함수의 고정 주소를 사용하는 방법.
**(1)** 동일한 버전의 Kernel을 설치하여, root 계정을 가지고 직접 주소를 따는 방법과 **(2)** `/proc/kallsyms` 등의 파일의 잘못된 권한 관리로 인한 leak.
이 방법들은 주소 PoC 코드 작성용으로만 사용되며, 최근 커널에서는 `kptr_restrict`, `KASLR` 등의 mitigation들 때문에 따로 leak 취약점을 이용해야 할 수 있다.
2. 커널 스택 하위에 존재하는 `thread_info` 구조체 내의 `task_struct` 구조체 내에는 `cred` 구조체를 가르키는 포인터 변수가 존재하는데, 해당 구조체가 `uid` `euid` `suid` 등의 값을 저장하고 있다.
이를 0으로 덮어 process 권한을 root 권한으로 상승시킬 수 있다.
이 방법은 좀 더 다양한 커널 버전에서 유효하다.

![lab3_img](/assets/lab3_img.PNG)


# do: LPE()
간단한 바이너리의 `getuid()`함수 호출시 발생하는 `sys_getuid()` 함수를 디버깅하여 위에서 설명한 권한 상승 방법 중, 2번째 방법을 통해 Local Privilege Escalation을 일으켜보자.

디버깅 할 바이너리의 코드는 다음과 같다.

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {

	uid_t uid;

	uid = getuid();

	printf("my uid = %d\n", uid);

	if (uid == 0)
		system("cat /etc/shadow");

	return 0;
}
```

**compile & run**
```sh
test@ubuntu:~/exercises/cred_struct$ gcc -o whatsmyuid whatsmyuid.c
test@ubuntu:~/exercises/cred_struct$ ls
whatsmyuid  whatsmyuid.c
test@ubuntu:~/exercises/cred_struct$ ./whatsmyuid
my uid = 1001
test@ubuntu:~/exercises/cred_struct$
```

`MasterVM`에서 해당 바이너리 실행시 `getuid()` 내에서 호출되는 `sys_getuid()` 함수에 BreakPoint를 잡는다.

**MasterVM**
```sh
root@master:~# gdb -q kernels/vmlinux-3.5.0-23-generic
Reading symbols from kernels/vmlinux-3.5.0-23-generic...done.
(gdb) target remote 192.168.94.1:8864
Remote debugging using 192.168.94.1:8864
native_safe_halt ()
    at /build/buildd/linux-lts-quantal-3.5.0/arch/x86/include/asm/irqflags.h:50
warning: Source file is more recent than executable.
50	}
(gdb) b * sys_getuid
Breakpoint 1 at 0xffffffff81065650: file /build/buildd/linux-lts-quantal-3.5.0/kernel/timer.c, line 1438.
(gdb) c
Continuing.
```

**TestVM**
```sh
test@ubuntu:~/exercises/cred_struct$ ./whatsmyuid
```

**MasterVM**
```sh
Breakpoint 4, sys_getuid ()
    at /build/buildd/linux-lts-quantal-3.5.0/kernel/timer.c:1438
1438	{
(gdb)
(gdb) disassemble sys_getuid
Dump of assembler code for function sys_getuid:
=> 0xffffffff81065650 <+0>:	push   rbp
   0xffffffff81065651 <+1>:	mov    rbp,rsp
   0xffffffff81065654 <+4>:	nop    DWORD PTR [rax+rax*1+0x0]
   0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700
   0xffffffff81065662 <+18>:	mov    rax,QWORD PTR [rax+0x458]
   0xffffffff81065669 <+25>:	pop    rbp
   0xffffffff8106566a <+26>:	mov    eax,DWORD PTR [rax+0x4]
   0xffffffff8106566d <+29>:	cmp    eax,0xffffffff
   0xffffffff81065670 <+32>:	cmove  eax,DWORD PTR [rip+0xbc5259]   # 0xffffffff81c2a8d0 <overflowuid>
   0xffffffff81065677 <+39>:	mov    eax,eax
   0xffffffff81065679 <+41>:	ret
End of assembler dump.
(gdb)
```

함수 디스어셈블을 확인해보면, 일단 `+9` 위치에서 `task_struct`의 주소를 받아오고, `+18`에서 `real_cred` 주소를 가져오고, `+26`에서 uid를 가져오는 것으로 보인다.

한번 하나씩 하나씩 주소를 확인해보자.
우선, `+9` 위치까지 실행을 시킨다.

```sh
(gdb) i r
rax            0x66	102
rbx            0x0	0
rcx            0x7fffe61049e0	140737053215200
rdx            0x7fffe6104d58	140737053216088
rsi            0x7fffe6104d48	140737053216072
rdi            0x1	1
rbp            0xffff8800780c5f78	0xffff8800780c5f78
rsp            0xffff8800780c5f78	0xffff8800780c5f78
r8             0x400670	4195952
r9             0x7fe57d3ce740	140623625381696
r10            0x7fffe61049e0	140737053215200
r11            0x206	518
r12            0x4004b0	4195504
r13            0x7fffe6104d40	140737053216064
r14            0x0	0
r15            0x0	0
rip            0xffffffff81065659	0xffffffff81065659 <sys_getuid+9>
eflags         0x297	[ CF PF AF SF IF ]
cs             0x10	16
ss             0x18	24
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) disassemble sys_getuid
Dump of assembler code for function sys_getuid:
   0xffffffff81065650 <+0>:	push   rbp
   0xffffffff81065651 <+1>:	mov    rbp,rsp
   0xffffffff81065654 <+4>:	nop    DWORD PTR [rax+rax*1+0x0]
=> 0xffffffff81065659 <+9>:	mov    rax,QWORD PTR gs:0xc700
   0xffffffff81065662 <+18>:	mov    rax,QWORD PTR [rax+0x458]
   0xffffffff81065669 <+25>:	pop    rbp
   0xffffffff8106566a <+26>:	mov    eax,DWORD PTR [rax+0x4]
   0xffffffff8106566d <+29>:	cmp    eax,0xffffffff
   0xffffffff81065670 <+32>:	cmove  eax,DWORD PTR [rip+0xbc5259]   # 0xffffffff81c2a8d0 <overflowuid>
   0xffffffff81065677 <+39>:	mov    eax,eax
   0xffffffff81065679 <+41>:	ret
End of assembler dump.
(gdb)
```

이제 `mov    rax,QWORD PTR gs:0xc700`명령을 통해 `gs:0xc700` 위치에 존재하는 `thread_info` 구조체의 첫번째 필드인 `task_struct`의 값을 가져올 것이다.

```sh
(gdb) ni
sys_getuid ()
    at /build/buildd/linux-lts-quantal-3.5.0/kernel/timer.c:1440
1440		return from_kuid_munged(current_user_ns(), current_uid());
(gdb) i r rax
rax            0xffff880076ccdc00	-131939402195968
(gdb)
```

메모리 영역을 `task_struct` 구조체 프레임을 씌워서 확인해보자.

```sh
(gdb) p (struct task_struct *) 0xffff880076ccdc00
$11 = (struct task_struct *) 0xffff880076ccdc00
(gdb) p *$11
$12 = {state = 0, stack = 0xffff8800780c4000, usage = {counter = 2},
  flags = 4202496, ptrace = 0, wake_entry = {
    next = 0x0 <irq_stack_union>}, on_cpu = 1, on_rq = 1, prio = 120,
  ...
  ...
      prev = 0xffff880076cce020}, {next = 0xffff880076cce030,
      prev = 0xffff880076cce030}, {next = 0xffff880076cce040,
      prev = 0xffff880076cce040}}, real_cred = 0xffff88007776e480,
  cred = 0xffff88007776e480, comm = "whatsmyuid\000\000\000\000\000",
  link_count = 0, total_link_count = 1, sysvsem = {
    undo_list = 0x0 <irq_stack_union>}, last_switch_count = 0,
    ...
    ...
(gdb)
```

출력된 구조체 내부 필드 중, `real_cred`의 값이 `0xffff88007776e480`으로 출력되는 것을 확인할 수 있다.

이제 `+26` 명령이 실행되면 `real_cred + 4`의 결과값인 `0xffff88007776e484` 주소에서 uid를 꺼내올 것이다.
gdb에서 확인해보자.

```sh
(gdb) p *$11.real_cred
$16 = {usage = {counter = 4}, uid = 1001, gid = 1001, suid = 1001,
  sgid = 1001, euid = 1001, egid = 1001, fsuid = 1001, fsgid = 1001,
  securebits = 0, cap_inheritable = {cap = {0, 0}}, cap_permitted = {
    cap = {0, 0}}, cap_effective = {cap = {0, 0}}, cap_bset = {cap = {
      4294967295, 4294967295}}, jit_keyring = 0 '\000',
  thread_keyring = 0x0 <irq_stack_union>,
  request_key_auth = 0x0 <irq_stack_union>,
  tgcred = 0xffff880036d170c0, security = 0xffff88007a5a72e0,
  user = 0xffff880079756e00,
  user_ns = 0xffffffff81c25700 <init_user_ns>,
  group_info = 0xffff880036c17800, rcu = {
    next = 0x0 <irq_stack_union>, func = 0x0 <irq_stack_union>}}

```

이제 `0xffff88007776e484` 주소의 값을 0으로 수정하여 `uid` 값이 0으로 반환되게 만든다.

```sh
(gdb) set *0xffff88007776e484=0
(gdb) x/wd 0xffff88007776e484
0xffff88007776e484:	0
(gdb) c
Continuing.
```


**TestVM**
```sh
test@ubuntu:~/exercises/cred_struct$ ./whatsmyuid
my uid = 0
cat: /etc/shadow: Permission denied
test@ubuntu:~/exercises/cred_struct$
```

uid값만 수정했기 때문에 uid는 0으로 반환되었지만 `/etc/shadow` 파일의 읽기 권한 검사는 패스하지 못한 듯 하다.


이번에는 `uid` `gid` `euid` `egid` 를 `0`으로 설정해본다.


**MasterVM**
```sh
(gdb) set $16.uid=0
(gdb) set $16.gid=0
(gdb) set $16.euid=0
(gdb) set $16.egid=0
(gdb) p *$11.real_cred
$21 = {usage = {counter = 4}, uid = 0, gid = 0, suid = 1001,
  sgid = 1001, euid = 0, egid = 0, fsuid = 1001, fsgid = 1001,
  securebits = 0, cap_inheritable = {cap = {0, 0}}, cap_permitted = {
    cap = {0, 0}}, cap_effective = {cap = {0, 0}}, cap_bset = {cap = {
      4294967295, 4294967295}}, jit_keyring = 0 '\000',
  thread_keyring = 0x0 <irq_stack_union>,
  request_key_auth = 0x0 <irq_stack_union>,
  tgcred = 0xffff880036d170c0, security = 0xffff88007a5a72e0,
  user = 0xffff880079756e00,
  user_ns = 0xffffffff81c25700 <init_user_ns>,
  group_info = 0xffff880036c17800, rcu = {
    next = 0x0 <irq_stack_union>, func = 0x0 <irq_stack_union>}}
(gdb) c
Continuing.
```

**TestVM**

```
test@ubuntu:~/exercises/cred_struct$ ./whatsmyuid
my uid = 0
root:$6$vUTGm6Ck$QJ6nTYRANRkFUTdo7dnXA7TmtU9ZUfQxRveJrinXs2Q44ydPueK6Zt2HWkv9yJtXRAHhI0YyNlq1pbf4EYmsj.:17010:0:99999:7:::
daemon:*:16599:0:99999:7:::
bin:*:16599:0:99999:7:::
sys:*:16599:0:99999:7:::
sync:*:16599:0:99999:7:::
...
...
test:$6$N9QrgFig$tjZaKZAWe3hBZOU9YItr1.geZmoCDR.QAWS61UfVa94.YWhyFnCfgnC.t2WflHsDtRTH1Js51HG6TgqAJGuqE0:17034:0:99999:7:::
test@ubuntu:~/exercises/cred_struct$
```

권한 상승을 통한 `/etc/shadow` 파일 읽기에 성공하였다.


# do: LPE() - automated

## 작성중....




# References
[thread_info를 통한 커널 익스 문제] <https://blackperl-security.gitlab.io/blog/2018/08/20/2018-08-20-sendpage_02_analysis/>
