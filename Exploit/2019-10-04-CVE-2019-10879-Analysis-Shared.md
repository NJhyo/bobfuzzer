---
layout: post
title: "CVE-2018-10879 Analysis-Shared"
author: "kimdong0219, ph4nt0m, nonetype"
---

# CVE-2018-10879 Analysis(Shared)

crash를 분석했을때 다음과 같은 3가지의 BUG가 발견되었다.

```c
[  108.120775] BUG: KASAN: use-after-free in ext4_xattr_free_space+0x200/0x300
[  245.355171] BUG: KASAN: use-after-free in ext4_xattr_set_entry+0x32bb/0x3390
[  288.371524] BUG: KASAN: slab-out-of-bounds in ext4_xattr_set_entry+0x1d66/0x3390
```

취약점 트리거링 이후 KASan이 잡는 함수는 아래와 같다.
1. `ext4_expand_extra_isize_ea -> ext4_xattr_free_space`
2. `ext4_expand_extra_isize_ea -> ext4_xattr_make_inode_space -> ext4_xattr_move_to_block -> ext4_xattr_block_set -> ext4_xattr_set_entry`.

---

## 공통 참고자료

### xattr 구조
```
/*
 * Extended attributes are stored directly in inodes (on file systems with
 * inodes bigger than 128 bytes) and on additional disk blocks. The i_file_acl
 * field contains the block number if an inode uses an additional block. All
 * attributes must fit in the inode and one additional block. Blocks that
 * contain the identical set of attributes may be shared among several inodes.
 * Identical blocks are detected by keeping a cache of blocks that have
 * recently been accessed.
 *
 * The attributes in inodes and on blocks have a different header; the entries
 * are stored in the same format:
 *
 *   +------------------+
 *   | header           |
 *   | entry 1          | |
 *   | entry 2          | | growing downwards
 *   | entry 3          | v
 *   | four null bytes  |
 *   | . . .            |
 *   | value 1          | ^
 *   | value 3          | | growing upwards
 *   | value 2          | |
 *   +------------------+
 *
 * The header is followed by multiple entry descriptors. In disk blocks, the
 * entry descriptors are kept sorted. In inodes, they are unsorted. The
 * attribute values are aligned to the end of the block in no specific order.
 *
 * Locking strategy
 * ----------------
 * EXT4_I(inode)->i_file_acl is protected by EXT4_I(inode)->xattr_sem.
 * EA blocks are only changed if they are exclusive to an inode, so
 * holding xattr_sem also means that nothing but the EA block's reference
 * count can change. Multiple writers to the same block are synchronized
 * by the buffer lock.
 */
```

### buffer_head
<http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch13lev1sec2.html>
<https://books.google.co.kr/books?id=3MWRMYRwulIC&pg=PA293&lpg=PA293&dq=buffer_head+reference+count&source=bl&ots=2bpAn9papc&sig=ACfU3U3K1uRIPd16XUQzi3rO6diA3WfxWQ&hl=ko&sa=X&ved=2ahUKEwjbm8-U14TlAhVCGaYKHfTCAxAQ6AEwAHoECAkQBA#v=onepage&q=buffer_head%20reference%20count&f=false>


---


### ext4_rename()
우선, 입력받은 인자값(inode, dentry)를 `ext4_renament` 구조체로 묶는다.
```c
struct ext4_renament old = {
		.dir = old_dir,
		.dentry = old_dentry,
		.inode = d_inode(old_dentry),
};
struct ext4_renament new = {
		.dir = new_dir,
		.dentry = new_dentry,
		.inode = d_inode(new_dentry),
};
```

이후 `ext4_find_entry` 호출을 통해 해당 `dir`, `dentry`에 맞는 entry를 찾아 `buffer_head`(cache buffer)를 채운다.
```c
old.bh = ext4_find_entry(old.dir, &old.dentry->d_name, &old.de, NULL);
...
new.bh = ext4_find_entry(new.dir, &new.dentry->d_name,
				 &new.de, &new.inlined);
```

만약 `new.bh`가 NULL이라면, `ext4_add_entry` 호출을 통해 기존 `inode`를 새로운 `dentry`에 연결한다.
```c
if (!new.bh) {
		retval = ext4_add_entry(handle, new.dentry, old.inode);
    ...
```

`new.bh`가 NULL이 아니라면, `ext4_setent` 호출을 통해 `new Dentry`의 inode 값을 `old Inode`의 값으로 변경한다.
```c
} else {
		retval = ext4_setent(handle, &new,
				     old.inode->i_ino, old_file_type);
    ...
```

변경 후 `old.inode`의 `ctime`을 현재 시각으로 변경한다.
```c
old.inode->i_ctime = current_time(old.inode);
```

`whiteout` 기능이 설정되지 않았다면, `ext4_rename_delete` 함수를 호출한다.

```c
if (!whiteout) {
	/*
	* ok, that's it
	*/
	ext4_rename_delete(handle, &old, force_reread); /* BUG::Call ext4_rename_delete */
}
```

### ext4_rename_delete()
`ext4_rename_delete` 함수에서의 흐름은 아래와 같다.

`ent->dentry->inode`와 `ent->inode`가 동일한지 체크 후, 같지 않다면 `ext4_find_delete_entry` 함수 호출을 통해 올바른 `inode`를 찾는다.
아마 레이스 컨디션 등을 통해 엉뚱한 `inode`가 삭제되지 않게 체크를 만들어 놓은듯 싶다.
```c
if (le32_to_cpu(ent->de->inode) != ent->inode->i_ino ||
	ent->de->name_len != ent->dentry->d_name.len ||
	strncmp(ent->de->name, ent->dentry->d_name.name,
	ent->de->name_len) ||
	force_reread) {
		retval = ext4_find_delete_entry(handle, ent->dir,
			&ent->dentry->d_name);
        ...
```

동일하다면, `ext4_delete_entry` 함수를 호출하여 `entry`를 삭제한다.
```c
} else {
	retval = ext4_delete_entry(handle, ent->dir, ent->de, ent->bh); /* BUG::Call ext4_delete_entry */
```

이후 위 함수들에서 오류가 발생한다면, `warning` 메시지를 띄워준다.
```c
if (retval) {
	ext4_warning_inode(ent->dir,
	  "Deleting old file: nlink %d, error=%d",
	  ent->dir->i_nlink, retval);
}
```

### ext4_delete_entry()

`ext4_has_inline_data` 호출을 통해 해당 `inode`가 `inline data`를 포함하고 있는지 확인 후, 포함한다면 `inline data`를 삭제하기 위해 `ext4_delete_inline_entry` 함수를 호출한다.
```c
if (ext4_has_inline_data(dir)) {
	int has_inline_data = 1;
	err = ext4_delete_inline_entry(handle, dir, de_del, bh, /* BUG::Call ext_delete_inline_entry */
				       &has_inline_data);
	if (has_inline_data)
		return err;
}
```

### ext4_delete_inline_entry()

`ext4_get_inode_loc` 함수 호출을 통해 `iloc` 변수에 디스크/메모리상의 inode의 위치를 받아온다.
```c
err = ext4_get_inode_loc(dir, &iloc);
```

`ext4_iloc` 구조체는 아래와 같이 정의되어 있다.
```c
/*
 * Describe an inode's exact location on disk and in memory
 */
struct ext4_iloc
{
	struct buffer_head *bh;
	unsigned long offset;
	ext4_group_t block_group;
};
```

이후 데이터의 길이를 체크하여 `EXT4_MIN_INLINE_DATA_SIZE` 기준으로 삭제할 데이터 시작 위치 `inline_start`와 삭제할 데이터 크기 `inline_size`를 설정한다.
```c
if ((void *)de_del - ((void *)ext4_raw_inode(&iloc)->i_block) <
	EXT4_MIN_INLINE_DATA_SIZE) {
	inline_start = (void *)ext4_raw_inode(&iloc)->i_block +
			EXT4_INLINE_DOTDOT_SIZE;
	inline_size = EXT4_MIN_INLINE_DATA_SIZE -
			EXT4_INLINE_DOTDOT_SIZE;
} else {
	inline_start = ext4_get_inline_xattr_pos(dir, &iloc);
	inline_size = ext4_get_inline_size(dir) -
			EXT4_MIN_INLINE_DATA_SIZE;
}
```

`inline_start`와 `inline_size`를 가지고 `ext4_generic_delete_entry` 함수를 호출한다.
```c
err = ext4_generic_delete_entry(handle, dir, de_del, bh,
					inline_start, inline_size, 0);
```



---

## `ext4_mark_inode_dirty` 분석
```c

<EXT4_SB/EXT4_I>

static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)
{
	return sb->s_fs_info; /*Filesystem private info*/
}
static inline struct ext4_inode_info *EXT4_I(struct inode *inode)
{
	return container_of(inode, struct ext4_inode_info, vfs_inode);
}

```
<br>

위의 구조체는 `ext4_mark_inode_dirty`에서 사용되는 파일시스템의 `superblock`과
`inode`의 정보들을 담고있다.<br>


<br>

```c
<ext4_mark_inode_dirty>

unsigned int s_want_extra_isize; /* New inodes should reserve # bytes */

if (EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize)
		ext4_try_to_expand_extra_isize(inode, sbi->s_want_extra_isize,iloc, handle)
```
<br>

ext4_mark_inode_dirty에서 `Extra isize`가 `s_want_extra_isize`보다 작으면 `ext4_try_to_expand_extra_isize`로 넘어간다.<br>

----

## `ext4_try_to_expand_extra_isize` 분석
```c
<ext4_try_to_expand_extra_isize>

static int ext4_try_to_expand_extra_isize(struct inode *inode, unsigned int new_extra_isize, struct ext4_iloc iloc, handle_t *handle)

if (ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND))
  return -EOVERFLOW; /* Value too large for defined data type */
if (ext4_handle_valid(handle) &&jbd2_journal_extend(handle, EXT4_DATA_TRANS_BLOCKS(inode->i_sb)) != 0)
  return -ENOSPC;  /* No space left on device */
if (ext4_write_trylock_xattr(inode, &no_expand) == 0)
  return -EBUSY; /* Device or resource busy */

error = __ext4_expand_extra_isize(inode, new_extra_isize, &iloc handle, &no_expand);
```
저널링을 하지 않는 모드에서는 즉시 inode를 확장 시도가 가능하다.<br>
저널 시스템에서는 `extra buffer credits`을 확보해야한다.<br>
그 이유는 우리가 동일한 방식으로EA block에 써주기 위해서이다.<br>
`journal_extend`가 실패하면 해당 `inode`의 기능성이 약간 상실되는데 기능이 중요하다면 충분한 `s_min_extra_isize`를 실행하도록 e2fsck를 실행해야한다.<br>
`ext4_try_to_expand_extra_isize`에서 `__ext4_expand_extra_isize`를 호출한다.<br>

----

## `__ext4_expand_extra_isize` 분석
```c
static int __ext4_expand_extra_isize(struct inode *inode,unsigned int new_extra_isize, struct ext4_iloc *iloc, handle_t *handle, int *no_expand)
{
  struct ext4_inode *raw_inode;
	struct ext4_xattr_ibody_header *header;
	int error;
	raw_inode = ext4_raw_inode(iloc);
	header = IHDR(inode, raw_inode);
  error = ext4_expand_extra_isize_ea(inode, new_extra_isize, raw_inode, handle);
	if (error) {
		/*
		 * Inode size expansion failed; don't try again
		 */
		*no_expand = 1;
	}

	return error;
}
```
<br>

`ext4_inode`의 구조체는 아래와 같다.<br>

```c
__le16	i_mode;		/* File mode */
__le16	i_uid;		/* Low 16 bits of Owner Uid */
__le32	i_size_lo;	/* Size in bytes */
__le32	i_atime;	/* Access time */
__le32	i_ctime;	/* Inode Change time */
__le32	i_mtime;	/* Modification time */
__le32	i_dtime;	/* Deletion Time */
__le16	i_gid;		/* Low 16 bits of Group Id */
__le16	i_links_count;	/* Links count */
__le32	i_blocks_lo;	/* Blocks count */
__le32	i_flags;	/* File flags */
```
<br>


`__ext4_expand_extra_isize`에서 `ext4_expand_extra_isize_ea`를 호출한다.<br>

----
## `ext4_expand_extra_isize_ea` 분석

```c
<ext4_expand_extra_isize_ea>
int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize, struct ext4_inode *raw_inode, handle_t *handle)
{
	struct ext4_xattr_ibody_header *header;
	struct buffer_head *bh;
	struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
	static unsigned int mnt_count;
	size_t min_offs;
	size_t ifree, bfree;
	int total_ino;
	void *base, *end;
	int error = 0, tried_min_extra_isize = 0;
	int s_min_extra_isize = le16_to_cpu(sbi->s_es->s_min_extra_isize);
	int isize_diff = new_extra_isize - EXT4_I(inode)->i_extra_isize;

}
```
함수에 선언된 인자들은 위와 같다.<br>
`isize_diff`는 우리가 i_extra_isize를 얼마나 키워야하는 지에 대한 인자이다.<br>
`isize_diff`= `new_extra_isize - EXT4_I->i_extra_isize` <br>

```c
<ext4_expand_extra_isize_ea>

retry:
	isize_diff = new_extra_isize - EXT4_I(inode)->i_extra_isize;
	if (EXT4_I(inode)->i_extra_isize >= new_extra_isize)
		return 0;
```
<br>

`i_extra_isize`가 `new_extra_isize`보다 클시 0을 반환시켜 버린다.<br>

```c
<ext4_expand_extra_isize_ea>에서 min_offs를 계산하는 방식이다.
	base = IFIRST(header);
	end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;
	min_offs = end - base;
	total_ino = sizeof(struct ext4_xattr_ibody_header);
```
`min_offs`를 계산하는 인자의 값들을 확인해보도록 하자.<br>

```c
#define EXT4_GOOD_OLD_INODE_SIZE 128
#define IHDR(inode, raw_inode) \
	((struct ext4_xattr_ibody_header *) \
		((void *)raw_inode + \
		EXT4_GOOD_OLD_INODE_SIZE + \
		EXT4_I(inode)->i_extra_isize))

#define IFIRST(hdr) ((struct ext4_xattr_entry *)((hdr)+1))

struct ext4_xattr_entry {
	__u8	e_name_len;	/* length of name */
	__u8	e_name_index;	/* attribute name index */
	__le16	e_value_offs;	/* offset in disk block of value */
	__le32	e_value_inum;	/* inode in which the value is stored */
	__le32	e_value_size;	/* size of attribute value */
	__le32	e_hash;		/* hash value of name and value */
	char	e_name[0];	/* attribute name */
};

struct ext4_xattr_ibody_header {
	__le32	h_magic;	/* magic number for identification */
};
```
<br>
```c
ifree = ext4_xattr_free_space(base, &min_offs, base, &total_ino);
	if (ifree >= isize_diff)
		goto shift;
```
`ifree`의 값이 `isize_diff`보다 크다면 shift함수로 보낸다.<br>
하지만 free space가 충분하지 않다면 EA block에 `new_extra_isize` bytes를 체크한다.<br>


```c
<ifree>
fuzzer@ubuntu df -i
Filesystem      Inodes  IUsed   IFree IUse% Mounted on
udev            494414    416  493998    1% /dev
tmpfs           501971    642  501329    1% /run
/dev/sda1      1905008 330225 1574783   18% /
tmpfs           501971      9  501962    1% /dev/shm
tmpfs           501971      4  501967    1% /run/lock
tmpfs           501971     17  501954    1% /sys/fs/cgroup
tmpfs           501971     31  501940    1% /run/user/1000
```
<br>

```c
<bfree>
fuzzer@ubuntu df -BM
Filesystem     1M-blocks   Used Available Use% Mounted on
udev               1932M     0M     1932M   0% /dev
tmpfs               393M    16M      377M   5% /run
/dev/sda1         29147M 10873M    16772M  40% /
tmpfs              1961M     1M     1961M   1% /dev/shm
tmpfs                 5M     0M        5M   0% /run/lock
tmpfs              1961M     0M     1961M   0% /sys/fs/cgroup
tmpfs               393M     1M      393M   1% /run/user/1000
```
```c
bfree = ext4_xattr_free_space(BFIRST(bh), &min_offs, base,
					      NULL);
		brelse(bh);
		if (bfree + ifree < isize_diff) {
			if (!tried_min_extra_isize && s_min_extra_isize) {
				tried_min_extra_isize++;
				new_extra_isize = s_min_extra_isize;
				goto retry;
			}
			error = -ENOSPC;
			goto cleanup;
		}
```
<br>

`ext4_xattr_free_space`를 호출하여 bfree에 값을 저장한다.<br>
`bfree + ifree`가 `isize_diff`보다 작다면 `retry`로 보낸다.<br>

```c
<ext4_expand_extra_isize_ea>



  	error = ext4_xattr_make_inode_space(handle, inode, raw_inode,
  					    isize_diff, ifree, bfree,
  					    &total_ino);
  	if (error) {
  		if (error == -ENOSPC && !tried_min_extra_isize &&
  		    s_min_extra_isize) {
  			tried_min_extra_isize++;
  			new_extra_isize = s_min_extra_isize;
  			goto retry;
  		}
  		goto cleanup;
  	}

```
<br>
```c
<shift>

    shift:
    	/* Adjust the offsets and shift the remaining entries ahead */
    	ext4_xattr_shift_entries(IFIRST(header), EXT4_I(inode)->i_extra_isize
    			- new_extra_isize, (void *)raw_inode +
    			EXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,
    			(void *)header, total_ino);
    	EXT4_I(inode)->i_extra_isize = new_extra_isize;
```
<br>

```c
<clean up>
      cleanup:
	if (error && (mnt_count != le16_to_cpu(sbi->s_es->s_mnt_count))) {
		ext4_warning(inode->i_sb, "Unable to expand inode %lu. Delete some EAs or run e2fsck.",
			     inode->i_ino);
		mnt_count = le16_to_cpu(sbi->s_es->s_mnt_count);
	}
	return error;
}
```



----
## `ext4_xattr_free_space` 분석

```c
static size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,
				    size_t *min_offs, void *base, int *total)
{
	for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
		if (!last->e_value_inum && last->e_value_size) {
			size_t offs = le16_to_cpu(last->e_value_offs);
			if (offs < *min_offs)
				*min_offs = offs;
		}
		if (total)
			*total += EXT4_XATTR_LEN(last->e_name_len);
	}
	return (*min_offs - ((void *)last - base) - sizeof(__u32));
}
 ```
`cleanup` 함수에서 error를 return하면 ext4_xattr_make_inode_space로 넘어가게 된다. <br>


----

## `ext4_xattr_make_inode_space` 분석

```c
<ext4_xattr_make_inode_space>

static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,
				       struct ext4_inode *raw_inode,
				       int isize_diff, size_t ifree,
				       size_t bfree, int *total_ino)
{
	struct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);
	struct ext4_xattr_entry *small_entry;
	struct ext4_xattr_entry *entry;
	struct ext4_xattr_entry *last;
	unsigned int entry_size;	/* EA entry size */
	unsigned int total_size;	/* EA entry size + value size */
	unsigned int min_total_size;
	int error;
 ```
<br>

`ext4_xattr_make_inode_space`에는 위와 같은 인자들이 선언되어있다.<br>

`ifree`가 할당해줘야 하는 추가적인 `isize`보다 작다면 EA 블록에 최적화(best-fit)된 entry를 찾는다.<br>

```c
while (isize_diff > ifree) {
  entry = NULL;
  small_entry = NULL;
  min_total_size = ~0U;
  last = IFIRST(header);
  for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {
    total_size = EXT4_XATTR_LEN(last->e_name_len);
    if (!last->e_value_inum)
      total_size += EXT4_XATTR_SIZE(
               le32_to_cpu(last->e_value_size));
    if (total_size <= bfree &&
        total_size < min_total_size) {
      if (total_size + ifree < isize_diff) {
        small_entry = last;
      } else {
        entry = last;
        min_total_size = total_size;
      }
    }
  }
 ```

 ```c
 entry_size = EXT4_XATTR_LEN(entry->e_name_len);
 total_size = entry_size;
 if (!entry->e_value_inum)
   total_size += EXT4_XATTR_SIZE(
             le32_to_cpu(entry->e_value_size));
 error = ext4_xattr_move_to_block(handle, inode, raw_inode,
          entry);
 if (error)
   return error;

 *total_ino -= entry_size;
 ifree += total_size;
 bfree -= total_size;
 ```

<!--
### ext4_xattr_make_inode_space()
`ext4_expand_extra_isize_ea` 함수에서 호출된다.
 ```c
...
error = ext4_xattr_make_inode_space(handle, inode, raw_inode, /* BUG::Call ext4_xattr_make_inode_space */
	isize_diff, ifree, bfree,
	&total_ino);
...
 ```
`isize_diff`는 확장해야 할 크기, `ifree`는 `ext4_xattr_free_space` 호출을 통해 반환받은 값(inode free?), `bfree`는 buffer free?(추가 예정)
`total_ino`는 `sizeof(struct ext4_xattr_ibody_header)` 결과값이다.

함수 내에서는 while-loop를 통해 필요한 크기(`isize_diff`)만큼 `best-fit`으로 찾아, `ext4_xattr_move_to_block` 함수를 호출한다.
-->

---

### ext4_xattr_move_to_block()
이 함수에서는, `ext4_xattr_make_inode_space()` 함수에서 찾은 `entry`의 value 크기만큼 `zmalloc`함수로 메모리 할당 후 해당 영역에 `entry`의 value를 `memcpy`한다.
이후 `entry`의 `e_name`도 동일하게 `memcpy`하고, `ext4_xattr_inode_loc()`을 호출한다.

### ext4_xattr_inode_loc()




---

### 1. KASAN Report
```
[  186.829072] ==================================================================
[  186.829072] BUG: KASAN: slab-out-of-bounds in ext4_xattr_free_space+0x200/0x300
[  186.829072] Read of size 4 at addr ffff880069c950a4 by task poc/1838
[  186.829072]
[  186.829072] CPU: 0 PID: 1838 Comm: poc Not tainted 4.17.0 #8
[  186.829072] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014
[  186.829072] Call Trace:
[  186.829072]  dump_stack+0xc2/0x16b
[  186.829072]  ? show_regs_print_info+0x5/0x5
[  186.829072]  ? kmsg_dump_rewind_nolock+0xd4/0xd4
[  186.829072]  ? __switch_to_asm+0x34/0x70
[  186.829072]  ? apic_timer_interrupt+0xa/0x20
[  186.829072]  print_address_description+0x6e/0x280
[  186.829072]  kasan_report+0x253/0x380
[  186.829072]  ? ext4_xattr_free_space+0x200/0x300
[  186.829072]  ext4_xattr_free_space+0x200/0x300
[  186.829072]  ext4_expand_extra_isize_ea+0x1140/0x17f0
[  186.829072]  ? jbd2_journal_try_to_free_buffers+0x480/0x480
[  186.829072]  ? ext4_xattr_set+0x330/0x330
[  186.829072]  ? __ext4_get_inode_loc+0x3d0/0xeb0
[  186.829072]  ? jbd2_journal_free_transaction+0x20/0x20
[  186.829072]  ? __jbd2_journal_temp_unlink_buffer+0x4f0/0x530
[  186.829072]  ? other_inode_match+0x9c0/0x9c0
[  186.829072]  __ext4_expand_extra_isize+0x152/0x280
[  186.829072]  ext4_mark_inode_dirty+0x5ff/0x870
[  186.829072]  ? ext4_expand_extra_isize+0x4c0/0x4c0
[  186.829072]  ? ext4_generic_delete_entry+0x1ad/0x470
[  186.829072]  ? ext4_create+0x500/0x500
[  186.829072]  ? up_read+0x20/0x20
[  186.829072]  ? jbd2_journal_get_write_access+0x3d/0x80
[  186.829072]  ext4_delete_inline_entry+0x33c/0x590
[  186.829072]  ? ext4_find_inline_entry+0x400/0x400
[  186.829072]  ? ext4_expand_extra_isize+0x4c0/0x4c0
[  186.829072]  ext4_delete_entry+0x2e0/0x460
[  186.829072]  ? ext4_generic_delete_entry+0x470/0x470
[  186.829072]  ext4_rename+0x1fca/0x2f60
[  186.829072]  ? ext4_tmpfile+0x400/0x400
[  186.829072]  ? ext4_find_entry+0x80a/0xef0
[  186.829072]  ? __d_alloc+0x63d/0xc60
[  186.829072]  ? lockref_get+0x1b2/0x310
[  186.829072]  ? blk_mq_debugfs_unregister_sched_hctx+0x70/0x70
[  186.829072]  ? take_dentry_name_snapshot+0xbb/0x270
[  186.829072]  vfs_rename+0x9d0/0x1810
[  186.829072]  ? vfs_link+0xaa0/0xaa0
[  186.829072]  ? __d_lookup+0x700/0x700
[  186.829072]  ? ext4_cross_rename+0x2040/0x2040
[  186.829072]  do_renameat2+0x9a6/0xec0
[  186.829072]  ? user_path_create+0x30/0x30
[  186.829072]  ? cpumask_weight.constprop.2+0x35/0x35
[  186.829072]  ? _cond_resched+0x12/0x60
[  186.829072]  ? downgrade_write+0x1a0/0x1a0
[  186.829072]  ? rcu_note_context_switch+0x440/0x440
[  186.829072]  ? __do_page_fault+0x47a/0xa60
[  186.829072]  ? __ia32_sys_brk+0x640/0x640
[  186.829072]  __x64_sys_rename+0x55/0x80
[  186.829072]  do_syscall_64+0x137/0x430
[  186.829072]  ? syscall_return_slowpath+0x2e0/0x2e0
[  186.829072]  ? do_page_fault+0x90/0x360
[  186.829072]  ? __do_page_fault+0xa60/0xa60
[  186.829072]  ? prepare_exit_to_usermode+0x1ae/0x200
[  186.829072]  ? perf_trace_sys_enter+0x1050/0x1050
[  186.829072]  ? __put_user_4+0x1c/0x30
[  186.829072]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  186.829072] RIP: 0033:0x7f6c101e0d47
[  186.829072] RSP: 002b:00007ffd135a0458 EFLAGS: 00000202 ORIG_RAX: 0000000000000052
[  186.829072] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f6c101e0d47
[  186.829072] RDX: 00005622611670a0 RSI: 00005622611670a0 RDI: 0000562261167080
[  186.829072] RBP: 00007ffd135a0490 R08: 0000562261167010 R09: 0000000000000000
[  186.829072] R10: 0000000000000642 R11: 0000000000000202 R12: 000056225f5125d0
[  186.829072] R13: 00007ffd135a0590 R14: 0000000000000000 R15: 0000000000000000
[  186.829072]
[  186.829072] Allocated by task 1831:
[  186.829072]  kasan_kmalloc+0xa0/0xd0
[  186.829072]  kmem_cache_alloc+0xbf/0x190
[  186.829072]  __kernfs_new_node+0xd7/0x560
[  186.829072]  kernfs_new_node+0x5c/0xf0
[  186.829072]  __kernfs_create_file+0x2d/0x260
[  186.829072]  sysfs_add_file_mode_ns+0x191/0x3f0
[  186.829072]  internal_create_group+0x1d0/0x8a0
[  186.829072]  sysfs_slab_add+0x19a/0x220
[  186.829072]  __kmem_cache_create+0x212/0x4e0
[  186.829072]  kmem_cache_create_usercopy+0x18f/0x2a0
[  186.829072]  kmem_cache_create+0xd/0x10
[  186.829072]  ext4_mb_init+0xa8e/0x1390
[  186.829072]  ext4_fill_super+0x654b/0xaba0
[  186.829072]  mount_bdev+0x255/0x300
[  186.829072]  mount_fs+0x50/0x2b0
[  186.829072]  vfs_kern_mount.part.26+0xb9/0x400
[  186.829072]  do_mount+0xd3a/0x28a0
[  186.829072]  ksys_mount+0x7b/0xd0
[  186.829072]  __x64_sys_mount+0xb5/0x150
[  186.829072]  do_syscall_64+0x137/0x430
[  186.829072]  entry_SYSCALL_64_after_hwframe+0x44/0xa9
[  186.829072]
[  186.829072] Freed by task 0:
[  186.829072] (stack is not available)
[  186.829072]
[  186.829072] The buggy address belongs to the object at ffff880069c95000
[  186.829072]  which belongs to the cache kernfs_node_cache of size 128
[  186.829072] The buggy address is located 36 bytes to the right of
[  186.829072]  128-byte region [ffff880069c95000, ffff880069c95080)
[  186.829072] The buggy address belongs to the page:
[  186.829072] page:ffffea0001a72540 count:1 mapcount:0 mapping:0000000000000000 index:0x0
[  186.829072] flags: 0x100000000000100(slab)
[  186.829072] raw: 0100000000000100 0000000000000000 0000000000000000 0000000100150015
[  186.829072] raw: dead000000000100 dead000000000200 ffff88006ccc3dc0 0000000000000000
[  186.829072] page dumped because: kasan: bad access detected
[  186.829072]
[  186.829072] Memory state around the buggy address:
[  186.829072]  ffff880069c94f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[  186.829072]  ffff880069c95000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[  186.829072] >ffff880069c95080: fc fc fc fc fc fc fc fc 00 00 00 00 00 00 00 00
[  186.829072]                                ^
[  186.829072]  ffff880069c95100: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc
[  186.829072]  ffff880069c95180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
[  186.829072] ==================================================================
[  186.829072] Disabling lock debugging due to kernel taint
[  186.972134] EXT4-fs error (device loop0): ext4_xattr_inode_iget:390: comm poc: error while reading EA inode 1970234923 err=-117
[  187.124759] EXT4-fs warning (device loop0): ext4_expand_extra_isize_ea:2791: Unable to expand inode 13. Delete some EAs or run e2fsck.

 ```

### 2. POC code

```c
static void activity(char *mpoint) {

  char *foo_bar_baz;
  char *foo_baz;
  int err;
  err = asprintf(&foo_bar_baz, "%s/foo/bar/baz", mpoint);
  err = asprintf(&foo_baz, "%s/foo/baz", mpoint);
  rename(foo_bar_baz, foo_baz);
}

int main(int argc, char *argv[]) {
  activity(argv[1]);
  return 0;
}
 ```

OOB와 UAF라고 내 지식으론 조금 다르게 리포트하고있는데 POC 소스의 rename 하는 부분부터 크래시가 터진다.
rename 부터 bp를 걸고 분석해봐야 겠다.

### 3. Break Point
```
Num     Type           Disp Enb Address            What
17      breakpoint     keep y   0xffffffff819c48b0 in ext4_xattr_free_space at fs/ext4/xattr.c:1332
18      breakpoint     keep y   0xffffffff818c135d in __ext4_expand_extra_isize at fs/ext4/inode.c:5797
	breakpoint already hit 2 times
19      breakpoint     keep y   0xffffffff818da24a in ext4_mark_inode_dirty at fs/ext4/inode.c:5841
	breakpoint already hit 2 times
20      breakpoint     keep y   0xffffffff819d6a7b in ext4_expand_extra_isize_ea at fs/ext4/xattr.c:2752
21      breakpoint     keep y   0xffffffff818bcb97 in ext4_delete_inline_entry at fs/ext4/inline.c:1706
22      breakpoint     keep y   0xffffffff8193990b in ext4_delete_entry at fs/ext4/namei.c:2346
23      breakpoint     keep y   0xffffffff8193e715 in ext4_rename at fs/ext4/namei.c:3393

 ```

1.ext4_mark_inode_dirty:5841

```C
call __ext4_expand_extra_isize(inode, new_extra_isize, &iloc, handle, &no_expand);
		inode = 0xb41ed
		new_extra_isize = 0x32
		&iloc = 0xffff880069ca7510
			[bh(buffer_head)=0xffff8800673c1b28, offset=768, block_group=0]
		handle = 0xffff8800673c0600
		&no_expand(0)
 ```

2.ext4_expand_extra_isize_ea:5797
```C
error = call ext4_expand_extra_isize_ea(inode, new_extra_isize, raw_inode, handle)
	inode = 0xb41ed
	new_extra_isize = 0x32
